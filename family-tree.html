<!doctype html>
<html lang="tr">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>Soy Aƒüacƒ± Olu≈üturucu</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f8f9fa;
      height: 100%;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
      overflow: hidden;
      touch-action: none;
    }

    html {
      height: 100%;
      overflow: hidden;
    }

    .container {
      max-width: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .main-content {
      display: flex;
      gap: 0;
      flex: 1;
      min-height: 0;
    }

    .sidebar {
      display: none;
      flex-direction: column;
      gap: 12px;
      width: 60px;
      background: white;
      padding: 8px;
      border-radius: 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border-right: 1px solid #e9ecef;
    }

    @media (min-width: 768px) {
      .sidebar {
        display: flex;
      }
    }

    @media (max-width: 767px) {
      .main-content {
        flex-direction: column;
      }
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 8px;
      background: white;
      border-bottom: 1px solid #e9ecef;
      gap: 8px;
      overflow-x: auto;
      flex-wrap: nowrap;
    }
#treeCanvas {
    position: relative;
    /* √ñnemli: Arka plan gridinin her yere yayƒ±lmasƒ± i√ßin */
    background-size: 50px 50px;
    background-image: radial-gradient(circle, #334155 1px, transparent 1px);
    overflow: visible !important; /* Dƒ±≈üarƒ± ta≈üan √ßizgileri kesme */
}

#svgConnections {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
    overflow: visible !important;
}

    .tree-icon {
      width: 44px;
      height: 44px;
      background: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      border: 1px solid #e9ecef;
      flex-shrink: 0;
    }

    .tree-icon svg {
      width: 28px;
      height: 28px;
    }

    .mobile-controls {
      display: flex;
      gap: 4px;
      align-items: center;
      flex-wrap: nowrap;
    }

    @media (min-width: 768px) {
      .mobile-controls {
        display: none;
      }
    }

    .controls {
      display: none;
    }

    .btn {
      padding: 10px 20px;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: 500;
      transition: all 0.2s ease;
      background: white;
      color: #495057;
    }

    .btn:hover {
      background: #f8f9fa;
      border-color: #adb5bd;
    }

    .btn-primary {
      background: #495057;
      color: white;
      border-color: #495057;
    }

    .btn-primary:hover {
      background: #343a40;
      border-color: #343a40;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
      border-color: #6c757d;
    }

    .btn-secondary:hover {
      background: #5a6268;
      border-color: #5a6268;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
      border-color: #dc3545;
    }

    .btn-danger:hover {
      background: #c82333;
      border-color: #c82333;
    }

    .btn-icon {
      width: 44px;
      height: 44px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      background: white;
      border: 1px solid #dee2e6;
      color: #495057;
    }

    .btn-icon:hover {
      background: #f8f9fa;
      border-color: #adb5bd;
    }

    .btn-icon svg {
      width: 20px;
      height: 20px;
      margin: auto;
    }

    .btn-icon .tooltip {
      position: absolute;
      left: 70px;
      background: #212529;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 0.85em;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 1000;
    }

    .btn-icon:hover .tooltip {
      opacity: 1;
    }

    .btn-icon .tooltip::before {
      content: '';
      position: absolute;
      left: -4px;
      top: 50%;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      border-right: 4px solid #212529;
    }

    .btn-icon-mobile {
      width: 40px;
      height: 40px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 1px solid #dee2e6;
      color: #495057;
      border-radius: 4px;
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.15s ease;
    }

    .btn-icon-mobile svg {
      width: 20px;
      height: 20px;
    }

    .btn-icon-mobile:active {
      background: #e9ecef;
      transform: scale(0.95);
    }

    .btn-icon-mobile.btn-primary {
      background: #495057;
      color: white;
      border-color: #495057;
    }

    .btn-icon-mobile.btn-danger {
      background: #dc3545;
      color: white;
      border-color: #dc3545;
    }

    .btn-import {
    background-color: #28a745;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    width: 100%;
    font-weight: bold;
    transition: background 0.3s;
}

.btn-import:hover {
    background-color: #218838;
}

    @media (min-width: 768px) {
      .btn-icon-mobile {
        display: none;
      }
    }

    .tree-container {
      background: white;
      padding: 0;
      border-radius: 0;
      box-shadow: none;
      overflow: hidden;
      position: relative;
      width: 100%;
      flex: 1;
      min-height: 0;
      touch-action: none;
      border: none;
      cursor: grab;
    }

    .tree-container.dragging {
      cursor: grabbing;
    }

    .tree-canvas {
      position: relative;
      min-width: 20000px;
      min-height: 20000px;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(200, 200, 200, 0.25) 2px, transparent 2px),
        linear-gradient(90deg, rgba(200, 200, 200, 0.25) 2px, transparent 2px);
      background-size: 40px 40px;
      background-position: 0 0;
      transform-origin: 0 0;
    }
    
    .tree-canvas.zoomed-in {
      background-image: 
        linear-gradient(rgba(200, 200, 200, 0.25) 2px, transparent 2px),
        linear-gradient(90deg, rgba(200, 200, 200, 0.25) 2px, transparent 2px);
    }
    
    .tree-canvas.zoomed-out {
      background-image: none;
    }

    .person-node {
      position: absolute;
      border-radius: 8px;
      padding: 20px 20px;
      cursor: move;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      min-width: 120px;
      text-align: center;
      z-index: 10;
      border: 3px solid rgba(255,255,255,0.3);
      user-select: none;
      touch-action: none;
    }

.old-spouse-line {
    stroke-dasharray: 5, 5; /* Kesik √ßizgi aralƒ±ƒüƒ± */
    stroke: #999;           /* Eski e≈ü √ßizgisini biraz daha soluk yapabilirsin */
}
    .person-node.male {
      background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
    }

    .person-node.female {
      background: linear-gradient(135deg, #f9a8d4 0%, #ec4899 100%);
    }

    .person-node:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
      z-index: 200;
    }

    .person-node.selected {
      border-color: #fbbf24;
      box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.5);
      z-index: 201;
    }

    .person-node.connecting {
      border-color: #10b981;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.5);
      animation: pulse 1s infinite;
    }

    .person-node.multi-selected {
      border-color: #8b5cf6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.5);
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.5); }
      50% { box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.3); }
    }

    .person-name {
      font-weight: bold;
      color: white;
      font-size: 1.1em;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .person-info {
      font-size: 0.85em;
      color: white;
      margin-top: 5px;
      padding-top: 5px;
      border-top: 1px solid rgba(255,255,255,0.3);
    }

    .info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      background: rgba(255,255,255,0.3);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-left: 5px;
      vertical-align: middle;
    }

    .info-icon:hover {
      background: rgba(255,255,255,0.5);
      transform: scale(1.1);
    }

    .info-icon svg {
      width: 12px;
      height: 12px;
      stroke: white;
      fill: none;
    }

    .person-actions {
      display: flex;
      gap: 5px;
      justify-content: center;
      margin-top: 10px;
    }

    .btn-small {
      padding: 6px 12px;
      font-size: 0.85em;
      border-radius: 5px;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 10000;
      padding: 20px;
      overflow-y: auto;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      max-width: 500px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 15px;
    }

    .modal-header h2 {
      color: #212529;
      font-size: 1.6em;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 2em;
      cursor: pointer;
      color: #999;
      line-height: 1;
    }

    .close-btn:hover {
      color: #333;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      color: #333;
      font-weight: 600;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1em;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #495057;
    }

    .parent-box {
      background: #f0f9ff;
      padding: 12px;
      border-radius: 8px;
      border: 2px solid #bae6fd;
      margin-bottom: 10px;
    }

    .parent-question {
      font-weight: 600;
      color: #0c4a6e;
      margin-bottom: 8px;
      text-align: center;
      font-size: 0.95em;
    }

    .existing-relationship-info {
      background: #fef3c7;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
      color: #92400e;
      font-weight: 600;
    }

    .toast {
      position: fixed;
      top: 80px;
      right: 20px;
      background: #48bb78;
      color: white;
      padding: 15px 25px;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
      z-index: 2000;
      display: none;
      max-width: 300px;
      font-size: 0.9em;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: break-word;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .toast.active {
      display: block;
    }

    .toast.error {
      background: #f56565;
    }

    svg.connection-line {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }



    .btn-full-width {
      width: 100%;
      margin-bottom: 10px;
    }

    .history-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .history-item {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }

    .history-item:hover {
      background: #e9ecef;
      border-color: #495057;
    }

    .history-item-date {
      font-weight: 600;
      color: #495057;
      margin-bottom: 5px;
    }

    .history-item-info {
      font-size: 0.9em;
      color: #6c757d;
    }

    .no-history {
      text-align: center;
      padding: 40px 20px;
      color: #6c757d;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>

 </head>
 <body>
  <div class="container">
   <div class="header">
    <div class="tree-icon">
    </div>
    <div class="mobile-controls"><button class="btn-icon-mobile" id="addPersonBtnMobile" title="Ki≈üi Ekle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin: auto;"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" /> <circle cx="8.5" cy="7" r="4" /> <line x1="20" y1="8" x2="20" y2="14" /> <line x1="23" y1="11" x2="17" y2="11" />
      </svg></button> <button class="btn-icon-mobile" id="multiSelectBtnMobile" title="Se√ßim Modu">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin: auto;"><rect x="3" y="3" width="7" height="7" /> <rect x="14" y="3" width="7" height="7" /> <rect x="14" y="14" width="7" height="7" /> <rect x="3" y="14" width="7" height="7" />
      </svg></button> <button id="editPersonBtnMobile" class="btn-icon-mobile btn-primary" style="display: none;" title="D√ºzenle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin: auto;"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /> <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
      </svg></button> <button id="deleteMultipleBtnMobile" class="btn-icon-mobile btn-danger" style="display: none;" title="Sil">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin: auto;"><polyline points="3 6 5 6 21 6" /> <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
      </svg></button> <button class="btn-icon-mobile" id="clearSelectionBtnMobile" title="Temizle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18" /> <line x1="6" y1="6" x2="18" y2="18" />
      </svg></button> <button class="btn-icon-mobile btn-primary" id="saveTreeBtnMobile" title="Kaydet">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /> <polyline points="17 21 17 13 7 13 7 21" /> <polyline points="7 3 7 8 15 8" />
      </svg></button> <button class="btn-icon-mobile" id="loadTreeBtnMobile" title="Y√ºkle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" /> <polyline points="14 2 14 8 20 8" /> <line x1="12" y1="18" x2="12" y2="12" /> <polyline points="9 15 12 12 15 15" />
      </svg></button> <button class="btn-icon-mobile" id="downloadImageBtnMobile" title="ƒ∞ndir">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /> <polyline points="7 10 12 15 17 10" /> <line x1="12" y1="15" x2="12" y2="3" />
      </svg></button>
    </div>
   </div>
   <div class="main-content">
    <div class="sidebar"><button class="btn btn-icon btn-primary" id="addPersonBtnSidebar" title="Ki≈üi Ekle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" /> <circle cx="8.5" cy="7" r="4" /> <line x1="20" y1="8" x2="20" y2="14" /> <line x1="23" y1="11" x2="17" y2="11" />
      </svg><span class="tooltip">Ki≈üi Ekle</span> </button> <button class="btn btn-icon btn-secondary" id="multiSelectBtnSidebar" title="√áoklu Se√ßim">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" /> <rect x="14" y="3" width="7" height="7" /> <rect x="14" y="14" width="7" height="7" /> <rect x="3" y="14" width="7" height="7" />
      </svg><span class="tooltip" id="multiSelectTooltip">√áoklu Se√ßim</span> </button> <button id="editPersonBtnSidebar" class="btn btn-icon btn-primary" style="display: none;" title="D√ºzenle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /> <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
      </svg><span class="tooltip">D√ºzenle</span> </button> <button id="deleteMultipleBtnSidebar" class="btn btn-icon btn-danger" style="display: none;" title="Se√ßilenleri Sil">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6" /> <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /> <line x1="10" y1="11" x2="10" y2="17" /> <line x1="14" y1="11" x2="14" y2="17" />
      </svg><span class="tooltip">Se√ßilenleri Sil</span> </button> <button class="btn btn-icon" id="clearSelectionBtnSidebar" title="Se√ßimi Temizle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18" /> <line x1="6" y1="6" x2="18" y2="18" />
      </svg><span class="tooltip">Se√ßimi Temizle</span> </button>
     <div style="height: 1px; background: #dee2e6; margin: 8px 0;"></div><button class="btn btn-icon btn-primary" id="saveTreeBtnSidebar" title="Kaydet">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /> <polyline points="17 21 17 13 7 13 7 21" /> <polyline points="7 3 7 8 15 8" />
      </svg><span class="tooltip">Kaydet</span> </button> <button class="btn btn-icon btn-secondary" id="loadTreeBtnSidebar" title="Y√ºkle">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" /> <polyline points="14 2 14 8 20 8" /> <line x1="12" y1="18" x2="12" y2="12" /> <polyline points="9 15 12 12 15 15" />
      </svg><span class="tooltip">Y√ºkle</span> </button> <button class="btn btn-icon" id="downloadImageBtnSidebar" title="G√∂rseli ƒ∞ndir">
      <svg viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /> <polyline points="7 10 12 15 17 10" /> <line x1="12" y1="15" x2="12" y2="3" />
      </svg><span class="tooltip">G√∂rseli ƒ∞ndir</span> </button>
    </div>
    <div style="flex: 1; display: flex; flex-direction: column; min-width: 0;">
     <div class="tree-container" id="treeContainer">
      <div class="tree-canvas" id="treeCanvas">
       <svg class="connection-line" id="svgConnections"></svg>
      </div>
     </div>
    </div>
   </div>
  </div>
  <div id="addPersonModal" class="modal">
   <div class="modal-content">
    <div class="modal-header">
     <h2 id="modalTitle">Yeni Ki≈üi Ekle</h2><button class="close-btn" id="closeModalBtn">√ó</button>
    </div>
    <form id="addPersonForm">
     <div class="form-group"><label for="personName">ƒ∞sim *</label> <input type="text" id="personName" required>
     </div>
     <div class="form-group"><label for="personGender">Cinsiyet *</label> <select id="personGender" required> <option value="">Se√ßiniz</option> <option value="erkek">Erkek</option> <option value="kadin">Kadƒ±n</option> </select>
     </div>
     <div class="form-group"><label for="personBirthYear">Doƒüum Yƒ±lƒ±</label> <input type="number" id="personBirthYear" min="1900" max="2024">
     </div>
     <div class="form-group"><label for="personNotes">Notlar</label> <textarea id="personNotes" rows="3"></textarea>
     </div><button type="submit" class="btn btn-primary btn-full-width">Kaydet</button>
    </form>
   </div>
  </div>
  <div id="relationshipModal" class="modal">
   <div class="modal-content">
    <div class="modal-header">
     <h2>Baƒülantƒ± T√ºr√º Se√ßin</h2><button class="close-btn" id="closeRelModalBtn">√ó</button>
    </div>
    <div style="padding: 20px 0;">
     <div id="existingRelationshipInfo" class="existing-relationship-info" style="display: none;"></div><button class="btn btn-primary btn-full-width" id="spouseBtn"> <span id="person1NameSpouse"></span> ve <span id="person2NameSpouse"></span> E≈ü </button>
     <div class="parent-box">
      <div class="parent-question"><strong><span id="person2NameQuestion"></span></strong>, <strong><span id="person1NameQuestion"></span></strong>'in nesi oluyor?
      </div><button class="btn btn-primary btn-full-width" id="parentChildBtn"> √áocuƒüu </button> <button class="btn btn-primary btn-full-width" id="childParentBtn" style="margin-bottom: 0;"> Anne/Babasƒ± </button>
     </div><button class="btn btn-primary btn-full-width" id="siblingBtn"> <span id="person1NameSibling"></span> ve <span id="person2NameSibling"></span> Karde≈ü </button> <button id="deleteRelationshipBtn" class="btn btn-danger btn-full-width" style="display: none;"> Mevcut Baƒüƒ± Sil </button> <button class="btn btn-secondary btn-full-width" id="cancelRelBtn" style="margin-bottom: 0;"> ƒ∞ptal </button>
    </div>
   </div>
  </div>
  <div id="loadHistoryModal" class="modal">
   <div class="modal-content">
    <div class="modal-header">
     <h2>Kayƒ±tlƒ± Soy Aƒüa√ßlarƒ±</h2><button class="close-btn" id="closeLoadModalBtn">√ó</button>
    </div>
    <div id="historyList" class="history-list"></div>
    <div class="manual-import-section" style="margin-bottom: 20px; padding: 15px; border-bottom: 1px dashed #ccc;">
    <button onclick="document.getElementById('fileInput').click()" class="btn-import">
        üìÇ Cihazdan Y√ºkle
    </button>
    <input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleManualImport(event)">
</div>
   </div>
  </div>
  <div id="personInfoModal" class="modal">
   <div class="modal-content">
    <div class="modal-header">
     <h2 id="infoModalName">Ki≈üi Bilgileri</h2><button class="close-btn" id="closeInfoModalBtn">√ó</button>
    </div>
    <div style="padding: 20px 0;">
     <div class="form-group"><label>ƒ∞sim:</label>
      <div id="infoName" style="padding: 12px; background: #f8f9fa; border-radius: 8px; font-weight: 600;"></div>
     </div>
     <div class="form-group"><label>Cinsiyet:</label>
      <div id="infoGender" style="padding: 12px; background: #f8f9fa; border-radius: 8px;"></div>
     </div>
     <div class="form-group"><label>Doƒüum Yƒ±lƒ±:</label>
      <div id="infoBirthYear" style="padding: 12px; background: #f8f9fa; border-radius: 8px;"></div>
     </div>
     <div class="form-group"><label>Notlar:</label>
      <div id="infoNotes" style="padding: 12px; background: #f8f9fa; border-radius: 8px; min-height: 60px; white-space: pre-wrap;"></div>
     </div><button class="btn btn-primary btn-full-width" id="editFromInfoBtn">D√ºzenle</button>
    </div>
   </div>
  </div>
  <div id="toast" class="toast"></div>
  <script>
   const CARD_WIDTH = 120;
const CARD_HEIGHT = 80;
const STORAGE_KEY = 'familyTreeData_v2'; // ƒ∞sim deƒüi≈ütirdim (A≈üaƒüƒ±da nedenini a√ßƒ±kladƒ±m)
const HISTORY_KEY = 'familyTreeHistory';
const MAX_HISTORY = 5;

let people = [
  { 
    id: 1, 
    name: 'Mehmet', 
    gender: 'erkek', 
    birthYear: 1950, 
    notes: '', 
    x: 10000, 
    y: 10000, 
    spouse: 2,       // ≈ûu anki aktif e≈ü
    spouses: [],     // YENƒ∞ EKLEME: Eski e≈üler listesi (Ba≈ülangƒ±√ßta bo≈ü)
    parents: [], 
    children: [3], 
    siblings: [] 
  },
  { 
    id: 2, 
    name: 'Ay≈üe', 
    gender: 'kadin', 
    birthYear: 1952, 
    notes: '', 
    x: 10200, 
    y: 10000, 
    spouse: 1,       // ≈ûu anki aktif e≈ü
    spouses: [],     // YENƒ∞ EKLEME
    parents: [], 
    children: [3], 
    siblings: [] 
  },
  { 
    id: 3, 
    name: 'Ahmet', 
    gender: 'erkek', 
    birthYear: 1975, 
    notes: '', 
    x: 10100, 
    y: 10200, 
    spouse: null, 
    spouses: [],     // YENƒ∞ EKLEME
    parents: [1, 2], 
    siblings: [] 
  }
];
window.people = people; // Bu satƒ±rƒ± ekle

// Diƒüer deƒüi≈ükenler aynen kalabilir
let selectedPerson = null;
let connectingPerson = null;
let draggedPerson = null;
let dragOffset = { x: 0, y: 0 };
let tempRelationship = { person1: null, person2: null };
let multiSelectMode = false;
let selectedPeople = new Set();
let draggedGroup = null;
let dragInitialPositions = null;
let editingPersonId = null;

    // Zoom variables
    let currentScale = 1;
    let currentTranslateX = 0;
    let currentTranslateY = 0;
    let lastTouchDistance = 0;
    let isPinching = false;
    let lastTouchCenter = { x: 0, y: 0 };

    // Grid panning variables
    let isGridDragging = false;
    let gridDragStartX = 0;
    let gridDragStartY = 0;
    let gridDragStartTranslateX = 0;
    let gridDragStartTranslateY = 0;

    // LocalStorage Functions
    function saveToLocalStorage() {
      try {
        const data = {
          people: people,
          timestamp: new Date().toISOString(),
          version: '1.0'
        };
        
        // Mevcut kaydƒ± history'e ekle
        saveToHistory(data);
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        showToast('‚úÖ Soy aƒüacƒ± kaydedildi!');
        return true;
      } catch (error) {
        showToast('‚ùå Kaydetme hatasƒ±: ' + error.message, true);
        return false;
      }
    }

    function saveToHistory(data) {
      try {
        let history = [];
        const historyData = localStorage.getItem(HISTORY_KEY);
        
        if (historyData) {
          history = JSON.parse(historyData);
        }
        
        // Yeni kaydƒ± ba≈üa ekle
        history.unshift(data);
        
        // Maksimum 5 kayƒ±t tut
        if (history.length > MAX_HISTORY) {
          history = history.slice(0, MAX_HISTORY);
        }
        
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      } catch (error) {
        console.error('History kaydetme hatasÔøΩÔøΩÔøΩÔøΩ:', error);
      }
    }

    function loadFromHistory(index) {
      try {
        const historyData = localStorage.getItem(HISTORY_KEY);
        if (!historyData) {
          showToast('Kayƒ±t bulunamadƒ±', true);
          return false;
        }

        const history = JSON.parse(historyData);
        if (index < 0 || index >= history.length) {
          showToast('Ge√ßersiz kayƒ±t', true);
          return false;
        }

        const data = history[index];
        people = data.people;
        
        const savedDate = new Date(data.timestamp);
        const dateStr = savedDate.toLocaleDateString('tr-TR') + ' ' + savedDate.toLocaleTimeString('tr-TR');
        
        closeLoadHistoryModal();
        renderTree();
        showToast('ÔøΩÔøΩÔøΩÔøΩÔøΩ Soy aƒüacƒ± y√ºklendi! (' + dateStr + ')');
        return true;
      } catch (error) {
        showToast('‚ùå Y√ºkleme hatasƒ±: ' + error.message, true);
        return false;
      }
    }

    function showLoadHistoryModal() {
      try {
        const historyData = localStorage.getItem(HISTORY_KEY);
        const historyList = document.getElementById('historyList');
        
        if (!historyData) {
          historyList.innerHTML = '<div class="no-history">üìÇ Hen√ºz kaydedilmi≈ü soy aƒüacƒ± yok</div>';
          document.getElementById('loadHistoryModal').classList.add('active');
          return;
        }

        const history = JSON.parse(historyData);
        
        if (history.length === 0) {
          historyList.innerHTML = '<div class="no-history">üìÇ Hen√ºz kaydedilmi≈ü soy aƒüacƒ± yok</div>';
          document.getElementById('loadHistoryModal').classList.add('active');
          return;
        }

        let html = '';
        history.forEach((item, index) => {
          const date = new Date(item.timestamp);
          const dateStr = date.toLocaleDateString('tr-TR', { 
            day: '2-digit', 
            month: '2-digit', 
            year: 'numeric' 
          });
          const timeStr = date.toLocaleTimeString('tr-TR', { 
            hour: '2-digit', 
            minute: '2-digit' 
          });
          const personCount = item.people ? item.people.length : 0;
          
          html += `
            <div class="history-item" onclick="loadFromHistory(${index})">
              <div class="history-item-date">üìÖ ${dateStr} - ${timeStr}</div>
              <div class="history-item-info">üë• ${personCount} ki≈üi</div>
            </div>
          `;
        });

        historyList.innerHTML = html;
        document.getElementById('loadHistoryModal').classList.add('active');
      } catch (error) {
        showToast('‚ùå Kayƒ±tlar y√ºklenemedi: ' + error.message, true);
      }
    }

    function closeLoadHistoryModal() {
      document.getElementById('loadHistoryModal').classList.remove('active');
    }

function handleManualImport(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      let rawData = JSON.parse(e.target.result);
      let peopleToLoad = [];

      // 1. ADIM: KATMANLARI SOYALIM
      // Senin verin: [ { people: [...] } ] ≈üeklinde ba≈ülƒ±yor.
      
      if (Array.isArray(rawData)) {
        if (rawData[0] && rawData[0].people && Array.isArray(rawData[0].people)) {
          // Senin √∂zel durumun: Dizinin ilk elemanƒ±nƒ±n i√ßindeki people dizisi
          peopleToLoad = rawData[0].people;
        } else {
          // Normal dizi durumu
          peopleToLoad = rawData;
        }
      } else if (rawData.people && Array.isArray(rawData.people)) {
        // Obje i√ßindeki people dizisi
        peopleToLoad = rawData.people;
      }

      if (!peopleToLoad || peopleToLoad.length === 0) {
        console.error("Ham veri √ß√∂z√ºmlenemedi:", rawData);
        showToast('Hata: Ge√ßerli ki≈üi listesi bulunamadƒ±!', true);
        return;
      }

      // 2. ADIM: GLOBAL Dƒ∞Zƒ∞YE AKTARIM
      const globalPeople = window.people || people;
      globalPeople.length = 0; // ƒ∞√ßini bo≈üalt

      // 3. ADIM: KOORDƒ∞NAT NORMALLE≈ûTƒ∞RME
      // Senin verinde x: 9400, y: 10880 gibi u√ß deƒüerler var.
      let allX = peopleToLoad.map(p => Number(p.x) || 0);
      let allY = peopleToLoad.map(p => Number(p.y) || 0);
      let minX = Math.min(...allX);
      let minY = Math.min(...allY);

      peopleToLoad.forEach((p, index) => {
        if (!p || typeof p !== 'object') return;

        // Koordinatlarƒ± 200,200 civarƒ±na √ßekiyoruz
        p.x = (Number(p.x) || 0) - minX + 200;
        p.y = (Number(p.y) || 0) - minY + 200;
        
        // Eksik alanlarƒ± tamamla (parents, children vb.)
        p.id = p.id || (Date.now() + index);
        p.parents = p.parents || [];
        p.children = p.children || []; // Yeni yapƒ±mƒ±z i√ßin kritik
        p.spouses = p.spouses || [];

        globalPeople.push(p);
      });

      // 4. ADIM: √áƒ∞FT Y√ñNL√ú BAƒûLARI ONAR (Ebeveynlerin children listesini doldur)
      globalPeople.forEach(child => {
        if (child.parents && child.parents.length > 0) {
          child.parents.forEach(pId => {
            const parent = globalPeople.find(pg => pg.id === pId);
            if (parent) {
              if (!parent.children) parent.children = [];
              if (!parent.children.includes(child.id)) {
                parent.children.push(child.id);
              }
            }
          });
        }
      });

      console.log("Ba≈üarƒ±yla y√ºklenen ger√ßek ki≈üi sayƒ±sƒ±:", globalPeople.length);

      // UI YENƒ∞LEME
      closeLoadHistoryModal();
      saveToLocalStorage();
      renderTree();
      
      showToast(`‚úÖ ${globalPeople.length} ki≈üi ba≈üarƒ±yla y√ºklendi!`);

    } catch (error) {
      console.error("Y√ºkleme Hatasƒ±:", error);
      showToast('‚ùå JSON dosyasƒ± okunamadƒ±!', true);
    }
  };
  reader.readAsText(file);
  event.target.value = ''; 
}

    function showPersonInfo(person) {
      document.getElementById('infoModalName').textContent = person.name;
      document.getElementById('infoName').textContent = person.name;
      document.getElementById('infoGender').textContent = person.gender === 'erkek' ? 'üë® Erkek' : 'üë© Kadƒ±n';
      document.getElementById('infoBirthYear').textContent = person.birthYear ? person.birthYear : 'Belirtilmemi≈ü';
      document.getElementById('infoNotes').textContent = person.notes || 'Not yok';
      
      const editBtn = document.getElementById('editFromInfoBtn');
      editBtn.onclick = function() {
        closePersonInfoModal();
        editPerson(person.id);
      };
      
      document.getElementById('personInfoModal').classList.add('active');
    }

    function closePersonInfoModal() {
      document.getElementById('personInfoModal').classList.remove('active');
    }

    function showToast(message, isError = false) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = 'toast active' + (isError ? ' error' : '');
      
      setTimeout(() => {
        toast.classList.remove('active');
      }, 3000);
    }

 function renderTree() {
  console.log("--- RENDER BA≈ûLADI ---");
  
  let source = window.people || people;
  if (!source || source.length === 0) {
    console.error("HATA: √áizilecek veri bulunamadƒ±!");
    return;
  }

  const activePeople = source.filter(p => p && p.id && p.name);
  const canvas = document.getElementById('treeCanvas');
  const svg = document.getElementById('svgConnections');
  
  if (!canvas) return;

  // --- 1. Dinamik Ofset Kilitleme (S√ºr√ºkleme Deneyimini D√ºzelten Kƒ±sƒ±m) ---
  let minX, minY, maxX, maxY;

  // Eƒüer bir ki≈üi s√ºr√ºkleniyorsa, ofsetleri deƒüi≈ütirmeyelim ki ekran kaymasƒ±n
  const isDraggingAnywhere = (typeof draggedPerson !== 'undefined' && draggedPerson !== null);

  if (isDraggingAnywhere && canvas.dataset.lastMinX) {
    // S√ºr√ºkleme anƒ±nda eski ofsetleri kullan
    minX = parseFloat(canvas.dataset.lastMinX);
    minY = parseFloat(canvas.dataset.lastMinY);
    console.log("S√ºr√ºkleme aktif: Ofsetler kilitlendi.");
  } else {
    // ƒ∞lk a√ßƒ±lƒ±≈üta veya s√ºr√ºkleme bittiƒüinde yeni ofsetleri hesapla
    let tempMinX = Infinity, tempMinY = Infinity, tempMaxX = -Infinity, tempMaxY = -Infinity;

    activePeople.forEach(p => {
      const x = Number(p.x) || 10000;
      const y = Number(p.y) || 10000;
      tempMinX = Math.min(tempMinX, x);
      tempMinY = Math.min(tempMinY, y);
      tempMaxX = Math.max(tempMaxX, x);
      tempMaxY = Math.max(tempMaxY, y);
    });

    const padding = 500;
    minX = tempMinX - padding;
    minY = tempMinY - padding;
    maxX = tempMaxX + padding;
    maxY = tempMaxY + padding;

    // Hesaplanan deƒüerleri "mƒ±knatƒ±slama" i√ßin kaydet
    canvas.dataset.lastMinX = minX;
    canvas.dataset.lastMinY = minY;
  }

  // --- 2. Boyutlandƒ±rma ---
  const canvasWidth = (maxX || (minX + 2000)) - minX;
  const canvasHeight = (maxY || (minY + 2000)) - minY;
  
  canvas.style.minWidth = canvasWidth + 'px';
  canvas.style.minHeight = canvasHeight + 'px';

  if (svg) {
    svg.setAttribute('width', canvasWidth);
    svg.setAttribute('height', canvasHeight);
    svg.innerHTML = ''; // Temizle
  }

  // --- 3. Kartlarƒ± Olu≈üturma ---
  // Temizlik (Sadece person-node'larƒ± sil, canvas'ƒ±n kendisini deƒüil)
  canvas.querySelectorAll('.person-node').forEach(n => n.remove());

  activePeople.forEach((person) => {
    try {
      const node = createPersonNode(person, minX, minY);
      if (node) canvas.appendChild(node);
    } catch (err) {
      console.error(`${person.name} hatasƒ±:`, err);
    }
  });

  // --- 4. Baƒülantƒ±lar ve Zoom ---
  // √áizgilerin kartlara tam oturmasƒ± i√ßin hesaplanan minX/minY'yi g√∂nderiyoruz
  if (typeof drawConnections === 'function') {
    drawConnections(minX, minY); 
  }

  if (typeof applyZoomTransform === 'function') {
    applyZoomTransform();
  }

  console.log("--- RENDER Bƒ∞TTƒ∞ ---");
}

// Global eri≈üim i√ßin
window.renderTree = renderTree;


    // Zoom functions
    function applyZoomTransform() {
      const canvas = document.getElementById('treeCanvas');
      
      canvas.style.transform = `scale(${currentScale}) translate(${currentTranslateX}px, ${currentTranslateY}px)`;
      canvas.style.transformOrigin = '0 0';
      canvas.style.transition = 'transform 0.3s ease-out';
      
      // Grid'i zoom seviyesine g√∂re g√∂ster/gizle
      // 1.0'dan k√º√ßÔøΩÔøΩkse (zoom out) grid'i gizle
      if (currentScale < 1.0) {
        canvas.classList.add('zoomed-out');
        canvas.classList.remove('zoomed-in');
      } else {
        canvas.classList.add('zoomed-in');
        canvas.classList.remove('zoomed-out');
      }
    }

    function getTouchDistance(touch1, touch2) {
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getTouchCenter(touch1, touch2) {
      return {
        x: (touch1.clientX + touch2.clientX) / 2,
        y: (touch1.clientY + touch2.clientY) / 2
      };
    }

    // Add pinch zoom handlers to tree container
    const treeContainer = document.getElementById('treeContainer');
    
    // Grid panning with mouse
    treeContainer.addEventListener('mousedown', function(e) {
      // Sadece bo≈ü alana tƒ±klandƒ±ƒüƒ±nda grid'i s√ºr√ºkle
      if (e.target === treeContainer || e.target.id === 'treeCanvas' || e.target.id === 'svgConnections') {
        isGridDragging = true;
        gridDragStartX = e.clientX;
        gridDragStartY = e.clientY;
        gridDragStartTranslateX = currentTranslateX;
        gridDragStartTranslateY = currentTranslateY;
        treeContainer.classList.add('dragging');
        e.preventDefault();
      }
    });

    document.addEventListener('mousemove', function(e) {
      if (isGridDragging) {
        const deltaX = e.clientX - gridDragStartX;
        const deltaY = e.clientY - gridDragStartY;
        
        currentTranslateX = gridDragStartTranslateX + deltaX / currentScale;
        currentTranslateY = gridDragStartTranslateY + deltaY / currentScale;
        
        applyZoomTransform();
        e.preventDefault();
      }
    });

    document.addEventListener('mouseup', function(e) {
      if (isGridDragging) {
        isGridDragging = false;
        treeContainer.classList.remove('dragging');
      }
    });

    // Desktop mouse wheel zoom with smooth animation
    let zoomTimeout = null;
    let accumulatedDelta = 0;
    
    treeContainer.addEventListener('wheel', function(e) {
      e.preventDefault();
      
      // Accumulate scroll delta for smoother zoom
      accumulatedDelta += e.deltaY;
      
      // Clear previous timeout
      if (zoomTimeout) {
        clearTimeout(zoomTimeout);
      }
      
      // Debounce zoom updates for smoother experience
      zoomTimeout = setTimeout(() => {
        const delta = accumulatedDelta > 0 ? 0.80 : 1.20; // Bigger steps for faster zoom
        const newScale = Math.max(0.5, Math.min(3, currentScale * delta));
        
        // Calculate zoom center point relative to container
        const containerRect = treeContainer.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;
        
        // Adjust translation to zoom towards mouse position
        const scaleDiff = newScale - currentScale;
        currentTranslateX -= (mouseX / currentScale) * scaleDiff / newScale;
        currentTranslateY -= (mouseY / currentScale) * scaleDiff / newScale;
        
        currentScale = newScale;
        applyZoomTransform();
        
        accumulatedDelta = 0;
      }, 10); // Small delay for accumulation
    }, { passive: false });
    
    treeContainer.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
        // √áoklu se√ßim modunda zoom'u devre dƒ±≈üƒ± bƒ±rak
        if (multiSelectMode) {
          e.preventDefault();
          return;
        }
        
        isPinching = true;
        isGridDragging = false;
        lastTouchDistance = getTouchDistance(e.touches[0], e.touches[1]);
        lastTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
        e.preventDefault();
      } else if (e.touches.length === 1) {
        // Tek parmak - sadece grid'e dokunulursa pan ba≈ülat
        const touch = e.touches[0];
        if (e.target === treeContainer || e.target.id === 'treeCanvas' || e.target.id === 'svgConnections') {
          isGridDragging = true;
          gridDragStartX = touch.clientX;
          gridDragStartY = touch.clientY;
          gridDragStartTranslateX = currentTranslateX;
          gridDragStartTranslateY = currentTranslateY;
          e.preventDefault();
        }
      }
    }, { passive: false });

    treeContainer.addEventListener('touchmove', function(e) {
      if (isPinching && e.touches.length === 2) {
        e.preventDefault();
        
        const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
        const currentCenter = getTouchCenter(e.touches[0], e.touches[1]);
        
        // Calculate scale change
        const scaleChange = currentDistance / lastTouchDistance;
        const newScale = Math.max(0.5, Math.min(3, currentScale * scaleChange));
        
        // Calculate translation to keep zoom centered
        const containerRect = treeContainer.getBoundingClientRect();
        const centerX = currentCenter.x - containerRect.left;
        const centerY = currentCenter.y - containerRect.top;
        
        const scaleDiff = newScale - currentScale;
        currentTranslateX -= (centerX / currentScale) * scaleDiff / newScale;
        currentTranslateY -= (centerY / currentScale) * scaleDiff / newScale;
        
        currentScale = newScale;
        lastTouchDistance = currentDistance;
        lastTouchCenter = currentCenter;
        
        applyZoomTransform();
      } else if (isGridDragging && e.touches.length === 1) {
        // Tek parmak kaydƒ±rma
        e.preventDefault();
        const touch = e.touches[0];
        const deltaX = touch.clientX - gridDragStartX;
        const deltaY = touch.clientY - gridDragStartY;
        
        currentTranslateX = gridDragStartTranslateX + deltaX / currentScale;
        currentTranslateY = gridDragStartTranslateY + deltaY / currentScale;
        
        applyZoomTransform();
      }
    }, { passive: false });

    treeContainer.addEventListener('touchend', function(e) {
      if (e.touches.length < 2) {
        isPinching = false;
        lastTouchDistance = 0;
      }
      if (e.touches.length === 0) {
        isGridDragging = false;
      }
    });


function drawConnections(offsetX, offsetY) {
    const svg = document.getElementById('svgConnections');
    if (!svg) return;
    svg.innerHTML = ''; // Temizle

    // 1. Veri Kaynaƒüƒ± G√ºvenliƒüi
    // window.people en g√ºncel halidir, yoksa parametre/global people'a bak
    const activePeople = window.people || (typeof people !== 'undefined' ? people : []);
    
    if (!Array.isArray(activePeople) || activePeople.length === 0) return;

    // --- A. EBEVEYN - √áOCUK BAƒûLANTILARI (Ye≈üil √áizgiler) ---
    const processedParentGroups = new Set();
    
    activePeople.forEach(child => {
        // Parents dizisi var mƒ±?
        if (child.parents && Array.isArray(child.parents) && child.parents.length > 0) {
            
            // KRƒ∞Tƒ∞K D√úZELTME: ID'leri sayƒ±ya √ßevirip sƒ±ralƒ±yoruz.
            // B√∂ylece ["1", "2"] ile [1, 2] aynƒ± grup sayƒ±lƒ±r.
            const parentIds = child.parents.map(id => Number(id));
            const parentKey = parentIds.sort((a, b) => a - b).join('-');

            if (!processedParentGroups.has(parentKey)) {
                // Bu ebeveyn grubuna ait t√ºm karde≈üleri bul
                const siblingGroup = activePeople.filter(p => {
                    if (!p.parents || p.parents.length === 0) return false;
                    const pKey = p.parents.map(id => Number(id)).sort((a, b) => a - b).join('-');
                    return pKey === parentKey;
                });
                
                // √áizim fonksiyonuna orijinal (raw) ID'leri deƒüil, siblingGroup nesnelerini g√∂nderiyoruz
                if (typeof drawParentToChildrenConnection === 'function') {
                    // child.parents (ID listesi) ve siblingGroup (Obje listesi)
                    drawParentToChildrenConnection(child.parents, siblingGroup, offsetX, offsetY);
                }
                
                processedParentGroups.add(parentKey);
            }
        }
    });

    // --- B. E≈û BAƒûLANTILARI (Turuncu/Gri √áizgiler) ---
    const drawnSpouses = new Set();
    
    activePeople.forEach(person => {
        const pId = Number(person.id);

        // 1. Aktif E≈ü
        if (person.spouse) {
            const sId = Number(person.spouse);
            const activeKey = [pId, sId].sort((a, b) => a - b).join('-');
            
            if (!drawnSpouses.has(activeKey)) {
                // E≈üi bulurken gev≈üek e≈üitlik (==) veya Number d√∂n√º≈ü√ºm√º kullan
                const spouse = activePeople.find(p => Number(p.id) === sId);
                
                if (spouse && typeof drawSpouseConnection === 'function') {
                    drawSpouseConnection(person, spouse, offsetX, offsetY, false); // false = D√ºz √ßizgi
                    drawnSpouses.add(activeKey);
                }
            }
        }

        // 2. Eski E≈üler
        if (person.spouses && Array.isArray(person.spouses) && person.spouses.length > 0) {
            person.spouses.forEach(rawSid => {
                const sId = Number(rawSid);
                const key = [pId, sId].sort((a, b) => a - b).join('-');
                
                if (!drawnSpouses.has(key)) {
                    const formerSpouse = activePeople.find(p => Number(p.id) === sId);
                    
                    if (formerSpouse && typeof drawSpouseConnection === 'function') {
                        drawSpouseConnection(person, formerSpouse, offsetX, offsetY, true); // true = Kesik √ßizgi
                        drawnSpouses.add(key);
                    }
                }
            });
        }
    });

    // --- C. KARDE≈û BAƒûLANTILARI (Mavi √áizgiler - Varsa) ---
    const processedSiblingGroups = new Set();
    
    activePeople.forEach(person => {
        if (person.siblings && Array.isArray(person.siblings) && person.siblings.length > 0) {
            // T√ºm ID'leri sayƒ±ya √ßevirip Set olu≈ütur (Tekrarlarƒ± √∂nlemek i√ßin)
            const allSiblingIds = new Set([Number(person.id), ...person.siblings.map(id => Number(id))]);
            
            // Benzersiz grup anahtarƒ±
            const groupKey = [...allSiblingIds].sort((a, b) => a - b).join('-');
            
            if (!processedSiblingGroups.has(groupKey)) {
                // Sadece bu gruptaki ki≈üileri filtrele
                const siblingGroup = activePeople.filter(p => allSiblingIds.has(Number(p.id)));
                
                if (siblingGroup.length > 1 && typeof drawSiblingConnection === 'function') {
                    drawSiblingConnection(siblingGroup, offsetX, offsetY);
                }
                processedSiblingGroups.add(groupKey);
            }
        }
    });
}

function drawSpouseConnection(person1, person2, offsetX, offsetY, isFormer = false) {
  // Koordinatlarƒ± ofsetlere g√∂re normalize et
  const centerX1 = (Number(person1.x) || 0) - offsetX;
  const centerY1 = (Number(person1.y) || 0) - offsetY;
  const centerX2 = (Number(person2.x) || 0) - offsetX;
  const centerY2 = (Number(person2.y) || 0) - offsetY;
  
  // Kart y√ºksekliƒüi kontrol√º (varsayƒ±lan 90px)
  const cH = (typeof CARD_HEIGHT !== 'undefined') ? CARD_HEIGHT : 90;
  
  const horizontalOffset = 0;
  const verticalOffset = cH / 2 + 70;      // Kartƒ±n altƒ±ndan ne kadar sarkacaƒüƒ±
  const verticalStartOffset = cH / 2 + 20; // Kartƒ±n i√ßinden/altƒ±ndan √ßƒ±kƒ±≈ü noktasƒ±
  
  // Baƒülantƒ± k√∂pr√ºs√ºn√ºn Y seviyesi (Hangi kart daha a≈üaƒüƒ±daysa ona g√∂re pay bƒ±rakƒ±r)
  const connectionY = Math.max(centerY1, centerY2) + verticalOffset;
  
  // Stil ayarlarƒ±
  const dash = isFormer ? '5,5' : '';
  const color = isFormer ? '#94a3b8' : '#f97316'; // Eski e≈ü: Gri, Aktif e≈ü: Turuncu
  const strokeWidth = 3;

  // 1. Hat: Birinci ki≈üiden a≈üaƒüƒ± inen dikme
  drawSVGLine(centerX1 + horizontalOffset, centerY1 + verticalStartOffset, centerX1 + horizontalOffset, connectionY, color, strokeWidth, dash);
  
  // 2. Hat: ƒ∞kinci ki≈üiden a≈üaƒüƒ± inen dikme
  drawSVGLine(centerX2 + horizontalOffset, centerY2 + verticalStartOffset, centerX2 + horizontalOffset, connectionY, color, strokeWidth, dash);
  
  // 3. Hat: ƒ∞ki dikmeyi birle≈ütiren yatay k√∂pr√º
  drawSVGLine(centerX1 + horizontalOffset, connectionY, centerX2 + horizontalOffset, connectionY, color, strokeWidth, dash);
}

    function drawSiblingConnection(siblingGroup, offsetX, offsetY) {
      if (!siblingGroup || siblingGroup.length < 2) return;
      
      const firstSibling = siblingGroup[0];
      const hasParents = firstSibling.parents && firstSibling.parents.length > 0;
      
      const minY = Math.min(...siblingGroup.map(s => s.y));
      const maxY = Math.max(...siblingGroup.map(s => s.y));
      const minX = Math.min(...siblingGroup.map(s => s.x));
      const maxX = Math.max(...siblingGroup.map(s => s.x));
      
      const verticalSpread = maxY - minY;
      const horizontalSpread = maxX - minX;
      
      // Yatay d√ºzenlemede - eski mantƒ±k
      if (verticalSpread <= horizontalSpread) {
        const horizontalOffset = 0;
        let connectionY;
        
        if (hasParents) {
          const childrenAvgY = siblingGroup.reduce((sum, s) => sum + s.y, 0) / siblingGroup.length;
          connectionY = childrenAvgY - CARD_HEIGHT / 2 - 20 - offsetY;
        } else {
          connectionY = minY - CARD_HEIGHT / 2 - 50 - offsetY;
        }
        
        siblingGroup.forEach(sibling => {
          const cardTop = sibling.y - CARD_HEIGHT / 2 - offsetY;
          drawSVGLine(sibling.x + horizontalOffset - offsetX, cardTop, sibling.x + horizontalOffset - offsetX, connectionY, '#3b82f6', 3);
        });
        
        // Sadece mavi yatay √ßizgiyi √ßiziyoruz
        drawSVGLine(minX + horizontalOffset - offsetX, connectionY, maxX + horizontalOffset - offsetX, connectionY, '#3b82f6', 3);
      } else {
        // Dikey d√ºzenleme - SADECE tam alt alta ise baƒüla
        siblingGroup.sort((a, b) => a.y - b.y);
        
        for (let i = 0; i < siblingGroup.length - 1; i++) {
          const sibling1 = siblingGroup[i];
          const sibling2 = siblingGroup[i + 1];
          
          // X koordinatlarƒ± tam aynƒ± mƒ± kontrol et (tam alt alta)
          if (Math.abs(sibling1.x - sibling2.x) === 0) {
            // Kartƒ±n merkezinde √ßizgi
            const lineX = sibling1.x - offsetX;
            const y1 = sibling1.y + 60 - offsetY;
            const y2 = sibling2.y + 60 - offsetY;
            
            drawSVGLine(lineX, y1, lineX, y2, '#3b82f6', 3, '', 50);
          }
        }
      }
    }

  function drawParentToChildrenConnection(parentIds, children, offsetX, offsetY) {
  if (!parentIds || parentIds.length === 0 || !children || children.length === 0) return;
  const source = window.people || people;

  // 1. Ebeveynleri Bul
  const parents = parentIds.map(id => source.find(p => p.id == id)).filter(Boolean);
  if (parents.length === 0) return;

  // 2. Koordinat Hesaplamalarƒ±
  const cH = (typeof CARD_HEIGHT !== 'undefined') ? CARD_HEIGHT : 90;

  // A. EBEVEYN √áIKI≈û NOKTASI (√ústteki Turuncu Hattƒ±n Ortasƒ±)
  const p1 = parents[0];
  const p2 = parents.length > 1 ? parents[1] : p1;
  const spouseMidX = ((p1.x + p2.x) / 2) - offsetX;
  const maxParentY = Math.max(p1.y, p2.y);
  const parentConnectionY = maxParentY + cH / 2 + 70 - offsetY;

  // B. MAVƒ∞ √áƒ∞ZGƒ∞ (KARDE≈ûLER) ORTA NOKTASI
  // √áocuklarƒ±n en soldaki ve en saƒüdaki olanƒ±nƒ± bulup merkezini hesaplƒ±yoruz
  const childrenX = children.map(c => c.x);
  const minChildX = Math.min(...childrenX);
  const maxChildX = Math.max(...childrenX);
  const siblingsMidX = ((minChildX + maxChildX) / 2) - offsetX;

  // Mavi √ßizginin (Karde≈ü barƒ±) Y seviyesi
  const minChildY = Math.min(...children.map(c => c.y));
  const siblingsBarY = minChildY - cH / 2 - 20 - offsetY;

  // 3. √áƒ∞Zƒ∞M ƒ∞≈ûLEMƒ∞ (Sadece 2 veya 3 √áizgi)
  
  // √áizgi Tipi
  let isDashed = false; // Daha √∂nceki mantƒ±ƒüƒ±n aynƒ±sƒ±...
  const dashArray = isDashed ? '5,5' : '';

  // 1. ADIM: Ebeveynlerden dikey ini≈ü (Karde≈ü barƒ± seviyesine kadar)
  drawSVGLine(spouseMidX, parentConnectionY, spouseMidX, siblingsBarY, '#10b981', 3, dashArray);

  // 2. ADIM: Eƒüer ebeveynlerin ortasƒ± ile karde≈ülerin ortasƒ± aynƒ± hizada deƒüilse
  // (Yani √ßocuklar ebeveynlere g√∂re saƒüa/sola kayƒ±ksa) yatay k√º√ß√ºk bir ye≈üil baƒülantƒ± √ßiz
  if (Math.abs(spouseMidX - siblingsMidX) > 1) {
    drawSVGLine(spouseMidX, siblingsBarY, siblingsMidX, siblingsBarY, '#10b981', 3, dashArray);
  }
}


function drawSVGLine(x1, y1, x2, y2, color, strokeWidth, dashArray = '') {
  const svg = document.getElementById('svgConnections');
  if (!svg) return;

  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  line.setAttribute('x1', x1);
  line.setAttribute('y1', y1);
  line.setAttribute('x2', x2);
  line.setAttribute('y2', y2);
  line.setAttribute('stroke', color);
  line.setAttribute('stroke-width', strokeWidth);
  
  if (dashArray) {
    line.setAttribute('stroke-dasharray', dashArray);
  }
  
  // √áizgilere bir sƒ±nƒ±f vererek CSS ile de y√∂netebilirsin
  line.setAttribute('class', 'tree-connection-line');
  
  svg.appendChild(line);
}
    function handlePersonClick(person) {
      if (multiSelectMode) {
        if (selectedPeople.has(person.id)) {
          selectedPeople.delete(person.id);
          showToast(person.name + ' se√ßimden √ßƒ±karƒ±ldƒ±');
        } else {
          selectedPeople.add(person.id);
          showToast(person.name + ' se√ßildi (' + selectedPeople.size + ' ki≈üi)');
        }
        
        const deleteBtnSidebar = document.getElementById('deleteMultipleBtnSidebar');
        const deleteBtnMobile = document.getElementById('deleteMultipleBtnMobile');
        const editBtnSidebar = document.getElementById('editPersonBtnSidebar');
        const editBtnMobile = document.getElementById('editPersonBtnMobile');
        
        const showDelete = selectedPeople.size > 0 ? 'inline-block' : 'none';
        const showEdit = selectedPeople.size === 1 ? 'inline-block' : 'none';
        
        deleteBtnSidebar.style.display = showDelete;
        if (deleteBtnMobile) deleteBtnMobile.style.display = showDelete;
        editBtnSidebar.style.display = showEdit;
        if (editBtnMobile) editBtnMobile.style.display = showEdit;
        
        renderTree();
        return;
      }
      
      if (connectingPerson) {
        if (connectingPerson.id === person.id) {
          connectingPerson = null;
          showToast('Baƒülantƒ± modu iptal edildi');
        } else {
          showRelationshipModal(connectingPerson, person);
        }
        renderTree();
      } else {
        connectingPerson = person;
        selectedPerson = null;
        showToast(person.name + ' se√ßildi! Baƒülanacak ki≈üiye tƒ±klayƒ±n...');
        renderTree();
      }
    }

function createPersonNode(person, offsetX, offsetY) {
  // 1. ADIM: Sayƒ±sal Deƒüer Kontrol√º (NaN Korumasƒ±)
  // Eƒüer person.x veya offsetX sayƒ± deƒüilse, varsayƒ±lan olarak 0 kabul et
  const px = Number(person.x) || 0;
  const py = Number(person.y) || 0;
  const ox = Number(offsetX) || 0;
  const oy = Number(offsetY) || 0;

  const node = document.createElement('div');
  
  // Cinsiyet sƒ±nƒ±fƒ±nƒ± g√ºvenli al (erkek/male, kadin/female e≈üle≈ümesi)
  const genderClass = (person.gender === 'erkek' || person.gender === 'male') ? 'male' : 'female';
  node.className = 'person-node ' + genderClass;
  
  // 2. ADIM: Durum Sƒ±nƒ±flarƒ±
  if (typeof selectedPerson !== 'undefined' && selectedPerson && selectedPerson.id === person.id) {
    node.classList.add('selected');
  }
  if (typeof connectingPerson !== 'undefined' && connectingPerson && connectingPerson.id === person.id) {
    node.classList.add('connecting');
  }
  if (typeof multiSelectMode !== 'undefined' && multiSelectMode && typeof selectedPeople !== 'undefined' && selectedPeople.has(person.id)) {
    node.classList.add('multi-selected');
  }

  // 3. ADIM: Pozisyon Hesaplama (Geli≈ütirilmi≈ü)
  // CARD_WIDTH ve CARD_HEIGHT'in tanƒ±mlƒ± olduƒüundan emin ol
  const cWidth = typeof CARD_WIDTH !== 'undefined' ? CARD_WIDTH : 150;
  const cHeight = typeof CARD_HEIGHT !== 'undefined' ? CARD_HEIGHT : 80;

  const leftPos = (px - (cWidth / 2) - ox);
  const topPos = (py - (cHeight / 2) - oy);

  node.style.left = leftPos + 'px';
  node.style.top = topPos + 'px';

  // Konsol Logu: Eƒüer kart 0,0 civarƒ±ndaysa veya √ßok uzaktaysa buradan takip et
  // console.log(`√áiziliyor: ${person.name} -> Left: ${node.style.left}, Top: ${node.style.top}`);

  node.innerHTML = `
    <div class="person-name">${person.name || 'ƒ∞simsiz'}</div>
    <div style="margin-top: 8px;">
      <span class="info-icon" data-person-id="${person.id}">
        <svg viewBox="0 0 24 24" stroke-width="2" width="16" height="16" fill="none" stroke="currentColor">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="16" x2="12" y2="12"/>
          <line x1="12" y1="8" x2="12.01" y2="8"/>
        </svg>
      </span>
    </div>
  `;

  // 4. ADIM: Event Listenerlar
  const infoIcon = node.querySelector('.info-icon');
  infoIcon.addEventListener('click', (e) => {
    e.stopPropagation();
    if (typeof showPersonInfo === 'function') showPersonInfo(person);
  });

  let dragStartTime = 0;
  let dragStartPos = { x: 0, y: 0 };
  let hasMoved = false;

  node.addEventListener('mousedown', (e) => {
    if (e.target.closest('button') || e.target.closest('.info-icon')) return;
    dragStartTime = Date.now();
    dragStartPos = { x: e.clientX, y: e.clientY };
    hasMoved = false;
    if (typeof startDrag === 'function') startDrag(e, person);
  });

  node.addEventListener('click', (e) => {
    if (e.target.closest('button') || e.target.closest('.info-icon')) return;
    
    const clickDuration = Date.now() - dragStartTime;
    const distance = Math.sqrt(
      Math.pow(e.clientX - dragStartPos.x, 2) + 
      Math.pow(e.clientY - dragStartPos.y, 2)
    );
    
    if (clickDuration < 300 && distance < 10 && !hasMoved) {
      if (typeof handlePersonClick === 'function') handlePersonClick(person);
    }
    e.stopPropagation();
  });

  // Mobil Dokunmatik Olaylar
  let touchStartTime = 0;
  let touchHasMoved = false;
  let touchStartPosition = { x: 0, y: 0 };
  
  node.addEventListener('touchstart', (e) => {
    if (e.target.closest('button') || e.target.closest('.info-icon')) return;
    
    const touch = e.touches[0];
    touchStartTime = Date.now();
    touchHasMoved = false;
    touchStartPosition = { x: touch.clientX, y: touch.clientY };
    
    const isMobile = window.innerWidth < 768;
    // Multi-select veya Masa√ºst√º modunda s√ºr√ºklemeye izin ver
    if (!isMobile || (typeof multiSelectMode !== 'undefined' && multiSelectMode)) {
        if (typeof startDragTouch === 'function') startDragTouch(touch, person);
        e.preventDefault();
    }
  }, { passive: false });

  node.addEventListener('touchmove', (e) => {
    const touch = e.touches[0];
    const distance = Math.sqrt(
      Math.pow(touch.clientX - touchStartPosition.x, 2) + 
      Math.pow(touch.clientY - touchStartPosition.y, 2)
    );
    if (distance > 10) touchHasMoved = true;
  }, { passive: false });

  node.addEventListener('touchend', (e) => {
    const touchDuration = Date.now() - touchStartTime;
    if (touchDuration < 300 && !touchHasMoved) {
      if (typeof handlePersonClick === 'function') handlePersonClick(person);
    }
    if (typeof stopDragTouch === 'function') stopDragTouch();
  });

  return node;
}
    function startDrag(e, person) {
      draggedPerson = person;
      
      // Grid s√ºr√ºklemesini devre dƒ±≈üƒ± bƒ±rak
      isGridDragging = false;
      
      // Mouse + canvas transform = doƒüru konum
      const canvas = document.getElementById('treeCanvas');
      const rect = canvas.getBoundingClientRect();
      
      const mouseXInCanvas = (e.clientX - rect.left) / currentScale - currentTranslateX;
      const mouseYInCanvas = (e.clientY - rect.top) / currentScale - currentTranslateY;
      
      dragOffset.x = mouseXInCanvas - person.x;
      dragOffset.y = mouseYInCanvas - person.y;

      if (multiSelectMode && selectedPeople.has(person.id)) {
        draggedGroup = Array.from(selectedPeople).map(id => people.find(p => p.id === id)).filter(Boolean);
        
        dragInitialPositions = {};
        draggedGroup.forEach(p => {
          dragInitialPositions[p.id] = { x: p.x, y: p.y };
        });
        
        dragOffset.refX = mouseXInCanvas - person.x;
        dragOffset.refY = mouseYInCanvas - person.y;
      } else {
        draggedGroup = null;
        dragInitialPositions = null;
      }

      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', stopDrag);
    }

    function startDragTouch(touch, person) {
      draggedPerson = person;
      
      // Grid s√ºr√ºklemesini devre dƒ±ÔøΩÔøΩƒ± bƒ±rak
      isGridDragging = false;
      
      const canvas = document.getElementById('treeCanvas');
      const rect = canvas.getBoundingClientRect();
      
      const touchXInCanvas = (touch.clientX - rect.left) / currentScale - currentTranslateX;
      const touchYInCanvas = (touch.clientY - rect.top) / currentScale - currentTranslateY;
      
      dragOffset.x = touchXInCanvas - person.x;
      dragOffset.y = touchYInCanvas - person.y;

      if (multiSelectMode && selectedPeople.has(person.id)) {
        draggedGroup = Array.from(selectedPeople).map(id => people.find(p => p.id === id)).filter(Boolean);
        
        dragInitialPositions = {};
        draggedGroup.forEach(p => {
          dragInitialPositions[p.id] = { x: p.x, y: p.y };
        });
        
        dragOffset.refX = touchXInCanvas - person.x;
        dragOffset.refY = touchYInCanvas - person.y;
      } else {
        draggedGroup = null;
        dragInitialPositions = null;
      }

      document.addEventListener('touchmove', dragTouch, { passive: false });
      document.addEventListener('touchend', stopDragTouch);
    }

    function drag(e) {
      if (!draggedPerson) return;
      hasMoved = true;

      const canvas = document.getElementById('treeCanvas');
      const rect = canvas.getBoundingClientRect();
      const gridSize = 20;

      const mouseXInCanvas = (e.clientX - rect.left) / currentScale - currentTranslateX;
      const mouseYInCanvas = (e.clientY - rect.top) / currentScale - currentTranslateY;

      if (draggedGroup && draggedGroup.length > 0) {
        const rawX = mouseXInCanvas - dragOffset.refX;
        const rawY = mouseYInCanvas - dragOffset.refY;
        
        const newX = Math.round(rawX / gridSize) * gridSize;
        const newY = Math.round(rawY / gridSize) * gridSize;
        
        const deltaX = newX - dragInitialPositions[draggedPerson.id].x;
        const deltaY = newY - dragInitialPositions[draggedPerson.id].y;
        
        draggedGroup.forEach(p => {
          const initialPos = dragInitialPositions[p.id];
          p.x = initialPos.x + deltaX;
          p.y = initialPos.y + deltaY;
        });
      } else {
        const rawX = mouseXInCanvas - dragOffset.x;
        const rawY = mouseYInCanvas - dragOffset.y;
        
        draggedPerson.x = Math.round(rawX / gridSize) * gridSize;
        draggedPerson.y = Math.round(rawY / gridSize) * gridSize;
      }

      renderTree();
    }

    function dragTouch(e) {
      if (!draggedPerson) return;
      e.preventDefault();

      const touch = e.touches[0];
      const canvas = document.getElementById('treeCanvas');
      const rect = canvas.getBoundingClientRect();
      const gridSize = 20;

      const touchXInCanvas = (touch.clientX - rect.left) / currentScale - currentTranslateX;
      const touchYInCanvas = (touch.clientY - rect.top) / currentScale - currentTranslateY;

      if (draggedGroup && draggedGroup.length > 0) {
        const rawX = touchXInCanvas - dragOffset.refX;
        const rawY = touchYInCanvas - dragOffset.refY;
        
        const newX = Math.round(rawX / gridSize) * gridSize;
        const newY = Math.round(rawY / gridSize) * gridSize;
        
        const deltaX = newX - dragInitialPositions[draggedPerson.id].x;
        const deltaY = newY - dragInitialPositions[draggedPerson.id].y;
        
        draggedGroup.forEach(p => {
          const initialPos = dragInitialPositions[p.id];
          p.x = initialPos.x + deltaX;
          p.y = initialPos.y + deltaY;
        });
      } else {
        const rawX = touchXInCanvas - dragOffset.x;
        const rawY = touchYInCanvas - dragOffset.y;
        
        draggedPerson.x = Math.round(rawX / gridSize) * gridSize;
        draggedPerson.y = Math.round(rawY / gridSize) * gridSize;
      }

      renderTree();
    }

 function stopDrag() {
  // Eƒüer bir ki≈üi ger√ßekten s√ºr√ºklendiyse (verisi varsa)
  if (draggedPerson) {
    // 1. Veriyi LocalStorage'a kaydet (Kalƒ±cƒ± olmasƒ± i√ßin)
    if (typeof saveToLocalStorage === 'function') {
      saveToLocalStorage();
    }
    
    // 2. T√úM AƒûACI YENƒ∞DEN √áƒ∞Z (√áizgilerin kartlara yapƒ±≈ümasƒ±nƒ± saƒülayan kritik adƒ±m)
    if (typeof renderTree === 'function') {
      renderTree();
    }
  }

  // Deƒüi≈ükenleri sƒ±fƒ±rla
  draggedPerson = null;
  draggedGroup = null;
  dragInitialPositions = null;
  
  // Event listener'larƒ± temizle
  document.removeEventListener('mousemove', drag);
  document.removeEventListener('mouseup', stopDrag);
}

    function stopDragTouch() {
  // 1. Eƒüer bir s√ºr√ºkleme i≈ülemi yapƒ±ldƒ±ysa g√ºncellemeleri yap
  if (draggedPerson || draggedGroup) {
    // √áizgilerin kartlara yapƒ±≈ümasƒ±nƒ± saƒüla ve yeni konumlarƒ± hesapla
    if (typeof renderTree === 'function') {
      renderTree();
    }
    
    // Deƒüi≈üiklikleri kalƒ±cƒ± hafƒ±zaya kaydet
    if (typeof saveToLocalStorage === 'function') {
      saveToLocalStorage();
    }
  }

  // 2. S√ºr√ºkleme deƒüi≈ükenlerini sƒ±fƒ±rla
  draggedPerson = null;
  draggedGroup = null;
  dragInitialPositions = null;
  
  // 3. Event listener'larƒ± kaldƒ±r (Bellek y√∂netimi i√ßin √∂nemli)
  document.removeEventListener('touchmove', dragTouch);
  document.removeEventListener('touchend', stopDragTouch);
}

function editPerson(personId) {
  const person = people.find(p => p.id === personId);
  if (!person) return;

  editingPersonId = personId;
  document.getElementById('modalTitle').textContent = 'Ki≈üiyi D√ºzenle';
  document.getElementById('personName').value = person.name;
  document.getElementById('personGender').value = person.gender;
  document.getElementById('personBirthYear').value = person.birthYear || '';
  document.getElementById('personNotes').value = person.notes || '';
  
  // --- EKLEMEN GEREKEN SATIR ---
  // Mevcut e≈üi se√ßili hale getirir (Eƒüer person.spouse varsa)
  if (document.getElementById('personSpouse')) {
    document.getElementById('personSpouse').value = person.spouse || '';
  }
  
  document.getElementById('addPersonModal').classList.add('active');
}

    function deletePerson(personId, buttonElement) {
      const person = people.find(p => p.id === personId);
      if (!person) return;
      
      if (buttonElement.textContent.includes('Onayla')) {
        if (person.spouse) {
          const spouse = people.find(p => p.id === person.spouse);
          if (spouse) spouse.spouse = null;
        }

        if (person.siblings) {
          person.siblings.forEach(sibId => {
            const sib = people.find(p => p.id === sibId);
            if (sib) {
              sib.siblings = sib.siblings.filter(s => s !== personId);
            }
          });
        }

        people.forEach(p => {
          if (p.parents && p.parents.includes(personId)) {
            p.parents = p.parents.filter(id => id !== personId);
          }
        });

        people = people.filter(p => p.id !== personId);
        
        renderTree();
        showToast(person.name + ' silindi!');
      } else {
        buttonElement.textContent = 'Onayla';
        buttonElement.style.background = '#c53030';
        setTimeout(() => {
          buttonElement.textContent = 'Sil';
          buttonElement.style.background = '#e53e3e';
        }, 3000);
      }
    }

    function getAllAncestors(personId) {
      const ancestors = new Set();
      const queue = [personId];
      
      while (queue.length > 0) {
        const currentId = queue.shift();
        const person = people.find(p => p.id === currentId);
        
        if (person && person.parents) {
          person.parents.forEach(parentId => {
            if (!ancestors.has(parentId)) {
              ancestors.add(parentId);
              queue.push(parentId);
            }
          });
        }
      }
      
      return ancestors;
    }

    function getAllDescendants(personId) {
      const descendants = new Set();
      const queue = [personId];
      
      while (queue.length > 0) {
        const currentId = queue.shift();
        people.forEach(person => {
          if (person.parents && person.parents.includes(currentId) && !descendants.has(person.id)) {
            descendants.add(person.id);
            queue.push(person.id);
          }
        });
      }
      
      return descendants;
    }

    function validateRelationship(person1, person2, type) {
      if (person1.id === person2.id) {
        return { valid: false, message: 'Bir ki≈üi kendisiyle ili≈ükilendirilemez!' };
      }

      if (type === 'spouse') {
        if (person1.gender === person2.gender) {
          return { valid: false, message: 'Aynƒ± cinsiyetten ki≈üiler e≈ü olamaz!' };
        }
      }

      const ancestors1 = getAllAncestors(person1.id);
      const descendants1 = getAllDescendants(person1.id);
      const ancestors2 = getAllAncestors(person2.id);
      const descendants2 = getAllDescendants(person2.id);

      // KARDE≈û ƒ∞Lƒ∞≈ûKƒ∞Sƒ∞ KONTROLLERI
      if (type === 'sibling') {
        // Direkt ata-torun kontrolleri
        if (ancestors1.has(person2.id) || descendants1.has(person2.id)) {
          return { valid: false, message: 'Farklƒ± ku≈üaklardaki ki≈üiler karde≈ü olamaz!' };
        }
        if (ancestors2.has(person1.id) || descendants2.has(person1.id)) {
          return { valid: false, message: 'Farklƒ± ku≈üaklardaki ki≈üiler karde≈ü olamaz!' };
        }
        if (person1.spouse === person2.id) {
          return { valid: false, message: 'E≈üler karde≈ü olamaz!' };
        }
        
        // √úVEY BABA/ANNE KONTROL√ú
        // Person1'in ebeveynlerinden biri Person2'nin e≈üi mi?
        if (person1.parents) {
          for (let parentId of person1.parents) {
            const parent = people.find(p => p.id === parentId);
            if (parent && parent.spouse === person2.id) {
              return { valid: false, message: '√úvey anne/baba ile √ºvey √ßocuk karde≈ü olamaz!' };
            }
          }
        }
        // Person2'nin ebeveynlerinden biri Person1'in e≈üi mi?
        if (person2.parents) {
          for (let parentId of person2.parents) {
            const parent = people.find(p => p.id === parentId);
            if (parent && parent.spouse === person1.id) {
              return { valid: false, message: '√úvey anne/baba ile √ºvey √ßocuk karde≈ü olamaz!' };
            }
          }
        }
        
        // √áAPRAZ KU≈ûAK: Dayƒ±/Amca-Yeƒüen kontrol√º
        // Person1'in ebeveynleri Person2'nin karde≈üi mi?
        if (person1.parents) {
          for (let parentId of person1.parents) {
            const parent = people.find(p => p.id === parentId);
            if (parent && parent.siblings && parent.siblings.includes(person2.id)) {
              return { valid: false, message: 'Dayƒ±/amca/teyze/hala ile yeƒüen karde≈ü olamaz!' };
            }
          }
        }
        // Person2'nin ebeveynleri Person1'in karde≈üi mi?
        if (person2.parents) {
          for (let parentId of person2.parents) {
            const parent = people.find(p => p.id === parentId);
            if (parent && parent.siblings && parent.siblings.includes(person1.id)) {
              return { valid: false, message: 'Dayƒ±/amca/teyze/hala ile yeƒüen karde≈ü olamaz!' };
            }
          }
        }
        
        // KUZEN KONTROL√ú: Karde≈ü √ßocuklarƒ± karde≈ü olamaz
        // Person1'in ebeveynleri ile Person2'nin ebeveynleri kardeÔøΩÔøΩÔøΩÔøΩ mi?
        if (person1.parents && person1.parents.length > 0 && person2.parents && person2.parents.length > 0) {
          for (let parent1Id of person1.parents) {
            const parent1 = people.find(p => p.id === parent1Id);
            if (parent1 && parent1.siblings) {
              for (let parent2Id of person2.parents) {
                if (parent1.siblings.includes(parent2Id)) {
                  return { valid: false, message: 'Kuzenler karde≈ü olamaz!' };
                }
              }
            }
          }
        }
      }

      // E≈û ƒ∞Lƒ∞≈ûKƒ∞Sƒ∞ KONTROLLERI
      if (type === 'spouse') {
        if (ancestors1.has(person2.id) || descendants1.has(person2.id)) {
          return { valid: false, message: 'Ata-torun ili≈ükisi olanlar e≈ü olamaz!' };
        }
        if (ancestors2.has(person1.id) || descendants2.has(person1.id)) {
          return { valid: false, message: 'Ata-torun ili≈ükisi olanlar e≈ü olamaz!' };
        }
        
        if (person1.siblings && person1.siblings.includes(person2.id)) {
          return { valid: false, message: 'Karde≈üler e≈ü olamaz!' };
        }
      }

      // EBEVEYN-√áOCUK ƒ∞Lƒ∞≈ûKƒ∞Sƒ∞ KONTROLLERI (Person1 -> Person2'nin ebeveyni)
      if (type === 'parent-child') {
        // Maksimum 2 ebeveyn kontrol√º
        if (person2.parents && person2.parents.length >= 2) {
          return { valid: false, message: person2.name + ' zaten 2 ebeveyni var! √ñnce birini silmelisiniz.' };
        }
        
        // Dede/Nine torunun ebeveyni olamaz
        if (ancestors1.has(person2.id)) {
          return { valid: false, message: 'Dede/nine torunun ebeveyni olamaz!' };
        }
        // Torun ata/ananƒ±n √ßocuƒüu olamaz
        if (descendants2.has(person1.id)) {
          return { valid: false, message: 'Torun ata/ananƒ±n √ßocuƒüu olamaz!' };
        }
        if (person1.siblings && person1.siblings.includes(person2.id)) {
          return { valid: false, message: 'Karde≈üler ebeveyn-√ßocuk olamaz!' };
        }
        if (person1.spouse === person2.id) {
          return { valid: false, message: 'E≈üler ebeveyn-√ßocuk olamaz!' };
        }
    
        
        // E≈û-√áOCUK √áAKI≈ûMASI: Person2'nin e≈üi Person1'in √ßocuƒüu ise engelle
        if (person2.spouse) {
          const spouse = people.find(p => p.id === person2.spouse);
          if (spouse && spouse.parents && spouse.parents.includes(person1.id)) {
            return { valid: false, message: '√áocuƒüunuzun e≈üi sizin √ßocuƒüunuz olamaz!' };
          }
        }
        
        // √áAPRAZ KU≈ûAK: Dayƒ± yeƒüeninin ebeveyni olamaz
        // Person1'in karde≈üleri Person2'nin torunlarƒ± mƒ±?
        if (person1.siblings) {
          for (let siblingId of person1.siblings) {
            if (descendants2.has(siblingId)) {
              return { valid: false, message: 'Dayƒ±/amca/teyze/hala yeƒüenin ebeveyni olamaz!' };
            }
          }
        }
        
        // Person2'nin karde≈üleri Person1'in atalarƒ± mƒ±?
        if (person2.siblings) {
          for (let siblingId of person2.siblings) {
            if (ancestors1.has(siblingId)) {
              return { valid: false, message: 'Yeƒüen dayƒ±/amca/teyze/halanƒ±n √ßocuƒüu olamaz!' };
            }
          }
        }
      }

      // √áOCUK-EBEVEYN ƒ∞Lƒ∞≈ûKƒ∞Sƒ∞ KONTROLLERI (Person2 -> Person1'in ebeveyni)
      if (type === 'child-parent') {
        // Maksimum 2 ebeveyn kontrol√º
        if (person1.parents && person1.parents.length >= 2) {
          return { valid: false, message: person1.name + ' zaten 2 ebeveyni var! √ñnce birini silmelisiniz.' };
        }
        
        // Dede/Nine torunun ebeveyni olamaz
        if (ancestors2.has(person1.id)) {
          return { valid: false, message: 'Dede/nine torunun ebeveyni olamaz!' };
        }
        // Torun ata/ananƒ±n √ßocuƒüu olamaz
        if (descendants1.has(person2.id)) {
          return { valid: false, message: 'Torun ata/ananƒ±n √ßocuƒüu olamaz!' };
        }
        if (person1.siblings && person1.siblings.includes(person2.id)) {
          return { valid: false, message: 'Karde≈üler ebeveyn-√ßocuk olamaz!' };
        }
        if (person1.spouse === person2.id) {
          return { valid: false, message: 'E≈üler ebeveyn-√ßocuk olamaz!' };
        }
        
        // E≈û-√áOCUK √áAKI≈ûMASI (D√úZELTÔøΩÔøΩÔøΩÔøΩLDƒ∞): Person2'nin e≈üi Person1'in √ßocuƒüu ise engelle
        // Senaryo: A-B e≈ü, C de A'nƒ±n √ßocuƒüu. B'yi (person2) C'nin (person1) ebeveyni yapmaya √ßalƒ±≈üƒ±yoruz.
        // Person2 (B)'nin e≈üi (A) Person1 (C)'nin ebeveyni mi kontrol et
        if (person2.spouse) {
          const spouse = people.find(p => p.id === person2.spouse);
          if (spouse && person1.parents && person1.parents.includes(spouse.id)) {
            // Burasƒ± doƒüru, bu normal bir durum (√ºvey ebeveyn eklemek)
            // Bu kontrol√º kaldƒ±rƒ±yoruz
          }
        }
        
        // E≈û-√áOCUK √áAKI≈ûMASI: Person1'in e≈üi Person2'nin √ßocuƒüu ise engelle
        if (person1.spouse) {
          const spouse = people.find(p => p.id === person1.spouse);
          if (spouse && spouse.parents && spouse.parents.includes(person2.id)) {
            return { valid: false, message: 'E≈üinizin ebeveyni sizin √ßocuƒüunuz olamaz!' };
          }
        }
        
        // √áAPRAZ KU≈ûAK: Yeƒüen dayƒ±sƒ±nƒ±n ebeveyni olamaz
        // Person2'nin karde≈üleri Person1'in torunlarƒ± mƒ±?
        if (person2.siblings) {
          for (let siblingId of person2.siblings) {
            if (descendants1.has(siblingId)) {
              return { valid: false, message: 'Yeƒüen dayƒ±/amca/teyze/halanƒ±n ebeveyni olamaz!' };
            }
          }
        }
        
        // Person1'in karde≈üleri Person2'nin atalarƒ± mƒ±?
        if (person1.siblings) {
          for (let siblingId of person1.siblings) {
            if (ancestors2.has(siblingId)) {
              return { valid: false, message: 'Dayƒ±/amca/teyze/hala yeƒüenin √ßocuƒüu olamaz!' };
            }
          }
        }
      }

      return { valid: true };
    }

    function checkExistingRelationship(person1, person2) {
      if (person1.spouse === person2.id) {
        return 'E≈ü';
      }
      if (person1.siblings && person1.siblings.includes(person2.id)) {
        return 'Karde≈ü';
      }
      if (person2.parents && person2.parents.includes(person1.id)) {
        return person1.name + ' - ' + person2.name + ' (Ebeveyn-√áocuk)';
      }
      if (person1.parents && person1.parents.includes(person2.id)) {
        return person2.name + ' - ' + person1.name + ' (Ebeveyn-√áocuk)';
      }
      
      return null;
    }

    function showRelationshipModal(person1, person2) {
      tempRelationship = { person1, person2 };
      
      document.getElementById('person1NameSpouse').textContent = person1.name;
      document.getElementById('person2NameSpouse').textContent = person2.name;
      document.getElementById('person1NameSibling').textContent = person1.name;
      document.getElementById('person2NameSibling').textContent = person2.name;
      document.getElementById('person1NameQuestion').textContent = person1.name;
      document.getElementById('person2NameQuestion').textContent = person2.name;
      
      const existingRel = checkExistingRelationship(person1, person2);
      const infoDiv = document.getElementById('existingRelationshipInfo');
      const deleteBtn = document.getElementById('deleteRelationshipBtn');
      
      if (existingRel) {
        infoDiv.textContent = 'Mevcut Baƒü: ' + existingRel;
        infoDiv.style.display = 'block';
        deleteBtn.style.display = 'block';
      } else {
        infoDiv.style.display = 'none';
        deleteBtn.style.display = 'none';
      }
      
      document.getElementById('relationshipModal').classList.add('active');
    }

    function autoLinkSiblings(person) {
      if (!person.parents || person.parents.length === 0) return;
      
      // SADECE her iki ki≈üinin de TAM 2 ebeveyni varsa VE bu 2 ebeveyn tamamen aynƒ±ysa karde≈ü yap
      // Tek ebeveynli √ßocuklar asla otomatik karde≈ü yapƒ±lmaz
      const potentialSiblings = people.filter(p => {
        if (p.id === person.id) return false;
        if (!p.parents || p.parents.length === 0) return false;
        
        // Her iki ki≈üinin de TAM OLARAK 2 ebeveyni olmalƒ± (tam karde≈ü kontrol√º)
        if (person.parents.length !== 2 || p.parents.length !== 2) return false;
        
        const personParents = [...person.parents].sort();
        const pParents = [...p.parents].sort();
        
        // TAMAMEN aynƒ± 2 ebeveyn mi kontrol et
        return JSON.stringify(personParents) === JSON.stringify(pParents);
      });
      
      if (potentialSiblings.length > 0) {
        const allSiblings = new Set([person.id, ...potentialSiblings.map(p => p.id)]);
        
        // Mevcut karde≈üleri ekleme - sadece yeni bulunanlarƒ± ekle
        allSiblings.forEach(id1 => {
          const p1 = people.find(p => p.id === id1);
          if (!p1) return;
          if (!p1.siblings) p1.siblings = [];
          
          allSiblings.forEach(id2 => {
            if (id1 !== id2 && !p1.siblings.includes(id2)) {
              p1.siblings.push(id2);
            }
          });
        });
      }
    }

function autoCompleteFamily(child, parent, relType) {
    const autoConnections = [];
    
    if (relType === 'parent-child' || relType === 'child-parent') {
        // ID'leri deƒüil, objelerin kendilerini aldƒ±ƒüƒ±mƒ±zdan emin olalƒ±m
        const theChild = relType === 'parent-child' ? parent : child;
        const theParent = relType === 'parent-child' ? child : parent;

        // parents dizisi yoksa olu≈ütur
        if (!theChild.parents) theChild.parents = [];

        // KURAL: Eƒüer √ßocuƒüun ≈üu an 1 ebeveyni varsa ve o ebeveynin sadece 1 AKTƒ∞F e≈üi varsa
        if (theChild.parents.length === 1) {
            const firstParentId = theChild.parents[0];
            const firstParent = people.find(p => p.id === firstParentId);
            
            if (firstParent && firstParent.spouse) {
                // Eski e≈üi (spouses dizisi) var mƒ± kontrol et
                const hasHistory = firstParent.spouses && firstParent.spouses.length > 0;
                
                // Sadece net durumda (ge√ßmi≈üi yoksa) otomatik ekle
                if (!hasHistory) {
                    const secondParentId = firstParent.spouse;
                    if (!theChild.parents.includes(secondParentId)) {
                        theChild.parents.push(secondParentId);
                        const p2 = people.find(p => p.id === secondParentId);
                        if (p2) autoConnections.push(p2.name + " eklendi.");
                    }
                }
            }
        }
    }
    
if (relType === 'sibling') {
    const person1 = child;
    const person2 = parent;
    
    if (person1.parents && person1.parents.length > 0) {
      if (!person2.parents) person2.parents = [];
      person1.parents.forEach(parentId => {
        if (!person2.parents.includes(parentId)) {
          person2.parents.push(parentId);
          const parentPerson = people.find(p => p.id === parentId);
          if (parentPerson) autoConnections.push(parentPerson.name + ' -> ' + person2.name + ' (Ebeveyn)');
        }
      });
    }

    if (person2.parents && person2.parents.length > 0) {
      if (!person1.parents) person1.parents = [];
      person2.parents.forEach(parentId => {
        if (!person1.parents.includes(parentId)) {
          person1.parents.push(parentId);
          const parentPerson = people.find(p => p.id === parentId);
          if (parentPerson) autoConnections.push(parentPerson.name + ' -> ' + person1.name + ' (Ebeveyn)');
        }
      });
    }
    autoLinkSiblings(person1);
    autoLinkSiblings(person2);
  }

     if (autoConnections.length > 0) {
    const message = 'Otomatik baƒülantƒ±lar:\n' + autoConnections.join('\n');
    showToast(message);
  }
}



  




function createRelationship(type) {
    const person1 = tempRelationship.person1;
    const person2 = tempRelationship.person2;
    
    if (!person1 || !person2) return;

    const validation = validateRelationship(person1, person2, type);
    if (!validation.valid) {
        showToast(validation.message, true);
        return;
    }

    if (type === 'spouse') {
        // --- PERSON 1 ƒ∞√áƒ∞N ESKƒ∞ E≈ûƒ∞ YEDEKLE ---
        if (person1.spouse && person1.spouse !== person2.id) {
            if (!person1.spouses) person1.spouses = [];
            if (!person1.spouses.includes(person1.spouse)) {
                person1.spouses.push(person1.spouse); // Eski e≈üi diziye at
            }
            // Eski e≈üin verisini de g√ºncelle
            const oldSpouse1 = people.find(p => p.id === person1.spouse);
            if (oldSpouse1) {
                oldSpouse1.spouse = null;
                if (!oldSpouse1.spouses) oldSpouse1.spouses = [];
                if (!oldSpouse1.spouses.includes(person1.id)) oldSpouse1.spouses.push(person1.id);
            }
        }

        // --- PERSON 2 ƒ∞√áƒ∞N ESKƒ∞ E≈ûƒ∞ YEDEKLE ---
        if (person2.spouse && person2.spouse !== person1.id) {
            if (!person2.spouses) person2.spouses = [];
            if (!person2.spouses.includes(person2.spouse)) {
                person2.spouses.push(person2.spouse); // Eski e≈üi diziye at
            }
            // Diƒüer eski e≈üin verisini g√ºncelle
            const oldSpouse2 = people.find(p => p.id === person2.spouse);
            if (oldSpouse2) {
                oldSpouse2.spouse = null;
                if (!oldSpouse2.spouses) oldSpouse2.spouses = [];
                if (!oldSpouse2.spouses.includes(person2.id)) oldSpouse2.spouses.push(person2.id);
            }
        }

        // YENƒ∞ AKTƒ∞F BAƒûLANTIYI KUR
        person1.spouse = person2.id;
        person2.spouse = person1.id;
        
        autoCompleteFamily(person1, person2, 'spouse');
        showToast(person1.name + ' ve ' + person2.name + ' e≈ü oldu!');
    } 

else if (type === 'parent-child') {
    // person1: Ebeveyn, person2: √áocuk

    // 1. √áocuƒüun (person2) parents dizisini kontrol et ve ekle
    if (!person2.parents) person2.parents = [];
    if (!person2.parents.includes(person1.id)) {
        person2.parents.push(person1.id);
    }

    // 2. Ebeveynin (person1) children dizisini kontrol et ve ekle (Yeni Eklenen Kƒ±sƒ±m)
    if (!person1.children) person1.children = [];
    if (!person1.children.includes(person2.id)) {
        person1.children.push(person2.id);
    }

    // 3. Otomatik ebeveyn tamamlama (E≈ü durumuna g√∂re 2. ebeveyni ekler)
    autoCompleteFamily(person2, person1, 'parent-child');

    // 4. G√∂rsel g√ºncelleme ve bildirim
    renderTree();
    saveToLocalStorage();
    showToast(person1.name + ' ebeveyn, ' + person2.name + ' √ßocuk olarak baƒülandƒ±!');
}
    else if (type === 'child-parent') {
    // person1: √áocuk, person2: Ebeveyn

    // 1. √áocuƒüun (person1) parents dizisini g√ºncelle
    if (!person1.parents) person1.parents = [];
    if (!person1.parents.includes(person2.id)) {
        person1.parents.push(person2.id);
    }

    // 2. Ebeveynin (person2) children dizisini g√ºncelle
    if (!person2.children) person2.children = [];
    if (!person2.children.includes(person1.id)) {
        person2.children.push(person1.id);
    }

    // 3. Otomatik aile tamamlama mantƒ±ƒüƒ±nƒ± √ßalƒ±≈ütƒ±r
    autoCompleteFamily(person1, person2, 'child-parent');

    // 4. G√∂rseli yenile ve kaydet
    renderTree();
    saveToLocalStorage();
    showToast(person2.name + ', ' + person1.name + '\'in ebeveyni olarak eklendi!');
}
      else if (type === 'sibling') {
        const allSiblings = new Set([person1.id, person2.id]);
        
        if (person1.siblings) {
          person1.siblings.forEach(id => allSiblings.add(id));
        }
        if (person2.siblings) {
          person2.siblings.forEach(id => allSiblings.add(id));
        }
        
        allSiblings.forEach(id1 => {
          const p1 = people.find(p => p.id === id1);
          if (!p1) return;
          if (!p1.siblings) p1.siblings = [];
          
          allSiblings.forEach(id2 => {
            if (id1 !== id2 && !p1.siblings.includes(id2)) {
              p1.siblings.push(id2);
            }
          });
        });
        
        // Karde≈ü yapƒ±ldƒ±ƒüƒ±nda ebeveynleri de otomatik aktar
        autoCompleteFamily(person1, person2, 'sibling');
        
        showToast(person1.name + ' ve ' + person2.name + ' kardeÔøΩÔøΩÔøΩÔøΩ oldu!');
      }

      closeRelationshipModal();
      renderTree();
    saveToLocalStorage(); // Her zaman en son kaydet
}

   function deleteExistingRelationship() {
  const person1 = tempRelationship.person1;
  const person2 = tempRelationship.person2;
  
  if (!person1 || !person2) return;
  
  // 1. AKTƒ∞F E≈û BAƒûINI Sƒ∞L
  if (person1.spouse === person2.id) {
    person1.spouse = null;
    person2.spouse = null;
    showToast('Aktif e≈ü baƒüƒ± silindi!');
  }
  
  // 2. ESKƒ∞ E≈û BAƒûINI Sƒ∞L (Kritik Eklem)
  // Eƒüer aralarƒ±nda eski bir e≈ü baƒüƒ± varsa (kesik √ßizgi), onu diziden temizler
  if (person1.spouses && person1.spouses.includes(person2.id)) {
    person1.spouses = person1.spouses.filter(id => id !== person2.id);
    if (person2.spouses) {
      person2.spouses = person2.spouses.filter(id => id !== person1.id);
    }
    showToast('Eski e≈ü baƒüƒ± kalƒ±cƒ± olarak silindi!');
  }

  // 3. KARDE≈û BAƒûINI Sƒ∞L (Mevcut mantƒ±k - Geli≈ütirildi)
  if (person1.siblings && person1.siblings.includes(person2.id)) {
    const person1Siblings = [...person1.siblings];
    
    person1.siblings = [];
    // Not: person1.parents = []; satƒ±rƒ± riskli olabilir, 
    // sadece gruptan ayƒ±rmak istiyorsanƒ±z parents kalsƒ±n denebilir.
    
    person1Siblings.forEach(siblingId => {
      const sibling = people.find(p => p.id === siblingId);
      if (sibling && sibling.siblings) {
        sibling.siblings = sibling.siblings.filter(id => id !== person1.id);
      }
    });
    
    showToast(person1.name + ' karde≈ü grubundan ayrƒ±ldƒ±!');
  }
  
  // 4. EBEVEYN-√áOCUK BAƒûINI Sƒ∞L (P1 Ebeveyn, P2 √áocuk)
  if (person2.parents && person2.parents.includes(person1.id)) {
    if (person2.siblings && person2.siblings.length > 0) {
      showToast('‚ö†Ô∏è √ñnce karde≈ülik baƒülarƒ±nƒ± silmelisiniz!', true);
      return;
    }
    person2.parents = person2.parents.filter(id => id !== person1.id);
    showToast('Ebeveyn-√ßocuk baƒüƒ± silindi!');
  }

  // 5. EBEVEYN-√áOCUK BAƒûINI Sƒ∞L (P2 Ebeveyn, P1 √áocuk)
  if (person1.parents && person1.parents.includes(person2.id)) {
    if (person1.siblings && person1.siblings.length > 0) {
      showToast('‚ö†Ô∏è √ñnce karde≈ülik baƒülarƒ±nƒ± silmelisiniz!', true);
      return;
    }
    person1.parents = person1.parents.filter(id => id !== person2.id);
    showToast('Ebeveyn-√ßocuk baƒüƒ± silindi!');
  }
  
  closeRelationshipModal();
  renderTree();
  saveToLocalStorage(); // Deƒüi≈üiklikleri kalƒ±cƒ± yap
}

    function closeRelationshipModal() {
      document.getElementById('relationshipModal').classList.remove('active');
      connectingPerson = null;
      saveToLocalStorage();
      renderTree();
    }

    // Event Listeners - Desktop sidebar buttons
    document.getElementById('addPersonBtnSidebar').addEventListener('click', openAddPersonModal);
    document.getElementById('multiSelectBtnSidebar').addEventListener('click', toggleMultiSelect);
    document.getElementById('editPersonBtnSidebar').addEventListener('click', editSelectedPerson);
    document.getElementById('deleteMultipleBtnSidebar').addEventListener('click', deleteMultiple);
    document.getElementById('clearSelectionBtnSidebar').addEventListener('click', clearSelection);
    document.getElementById('saveTreeBtnSidebar').addEventListener('click', saveToLocalStorage);
    document.getElementById('loadTreeBtnSidebar').addEventListener('click', showLoadHistoryModal);
    document.getElementById('downloadImageBtnSidebar').addEventListener('click', downloadImage);

    // Event Listeners - Mobile buttons
    document.getElementById('addPersonBtnMobile').addEventListener('click', openAddPersonModal);
    document.getElementById('multiSelectBtnMobile').addEventListener('click', toggleMultiSelect);
    document.getElementById('editPersonBtnMobile').addEventListener('click', editSelectedPerson);
    document.getElementById('deleteMultipleBtnMobile').addEventListener('click', deleteMultiple);
    document.getElementById('clearSelectionBtnMobile').addEventListener('click', clearSelection);
    document.getElementById('saveTreeBtnMobile').addEventListener('click', saveToLocalStorage);
    document.getElementById('loadTreeBtnMobile').addEventListener('click', showLoadHistoryModal);
    document.getElementById('downloadImageBtnMobile').addEventListener('click', downloadImage);

    // Event Listeners - Load history modal
    document.getElementById('closeLoadModalBtn').addEventListener('click', closeLoadHistoryModal);
    
    // Event Listeners - Person info modal
    document.getElementById('closeInfoModalBtn').addEventListener('click', closePersonInfoModal);

    function openAddPersonModal() {
      editingPersonId = null;
      document.getElementById('modalTitle').textContent = 'Yeni Ki≈üi Ekle';
      document.getElementById('addPersonModal').classList.add('active');
      document.getElementById('addPersonForm').reset();
    }

    function editSelectedPerson() {
      if (selectedPeople.size !== 1) return;
      
      const personId = Array.from(selectedPeople)[0];
      editPerson(personId);
    }

    function toggleMultiSelect() {
      multiSelectMode = !multiSelectMode;
      
      const tooltip = document.getElementById('multiSelectTooltip');
      const deleteBtnSidebar = document.getElementById('deleteMultipleBtnSidebar');
      const deleteBtnMobile = document.getElementById('deleteMultipleBtnMobile');
      const editBtnSidebar = document.getElementById('editPersonBtnSidebar');
      const editBtnMobile = document.getElementById('editPersonBtnMobile');
      const multiSelectBtnSidebar = document.getElementById('multiSelectBtnSidebar');
      const multiSelectBtnMobile = document.getElementById('multiSelectBtnMobile');
      
      if (multiSelectMode) {
        if (tooltip) tooltip.textContent = '√áoklu Se√ßim: A√ßƒ±k';
        multiSelectBtnSidebar.style.borderColor = '#10b981';
        multiSelectBtnSidebar.style.background = '#d1fae5';
        multiSelectBtnMobile.style.borderColor = '#10b981';
        multiSelectBtnMobile.style.background = '#d1fae5';
        showToast('Se√ßim modu a√ßƒ±ldƒ±!');
      } else {
        if (tooltip) tooltip.textContent = '√áoklu Se√ßim';
        multiSelectBtnSidebar.style.borderColor = '#dee2e6';
        multiSelectBtnSidebar.style.background = 'white';
        multiSelectBtnMobile.style.borderColor = '#dee2e6';
        multiSelectBtnMobile.style.background = 'white';
        selectedPeople.clear();
        deleteBtnSidebar.style.display = 'none';
        editBtnSidebar.style.display = 'none';
        if (deleteBtnMobile) deleteBtnMobile.style.display = 'none';
        if (editBtnMobile) editBtnMobile.style.display = 'none';
        showToast('Se√ßim modu kapatƒ±ldƒ±');
      }
      
      connectingPerson = null;
      selectedPerson = null;
      renderTree();
    }

function deleteMultiple() {
    if (selectedPeople.size === 0) return;

    const deleteBtnSidebar = document.getElementById('deleteMultipleBtnSidebar');
    const deleteBtnMobile = document.getElementById('deleteMultipleBtnMobile');

    if (deleteBtnSidebar.title.includes('Emin misiniz?')) {
        selectedPeople.forEach(personId => {
            const person = people.find(p => p.id === personId);
            if (!person) return;

            // 1. Aktif E≈ü Baƒüƒ±nƒ± Temizle
            if (person.spouse) {
                const spouse = people.find(p => p.id === person.spouse);
                if (spouse) spouse.spouse = null;
            }

            // 2. Eski E≈üler (spouses) Listesinden Temizle
            people.forEach(p => {
                if (p.spouses && p.spouses.includes(personId)) {
                    p.spouses = p.spouses.filter(id => id !== personId);
                }
            });

            // 3. Karde≈ü Baƒülarƒ±nƒ± Temizle
            if (person.siblings) {
                person.siblings.forEach(sibId => {
                    const sib = people.find(p => p.id === sibId);
                    if (sib && sib.siblings) {
                        sib.siblings = sib.siblings.filter(id => id !== personId);
                    }
                });
            }

            // 4. Ebeveyn Baƒülarƒ±nƒ± (√áocuklardan) Temizle
            people.forEach(p => {
                if (p.parents && p.parents.includes(personId)) {
                    p.parents = p.parents.filter(id => id !== personId);
                }
            });
        });

        // Veriyi Filtrele ve Sil
        people = people.filter(p => !selectedPeople.has(p.id));

        const count = selectedPeople.size;
        selectedPeople.clear();
        multiSelectMode = false;
        
        // UI G√ºncelleme
        if (document.getElementById('multiSelectTooltip')) {
            document.getElementById('multiSelectTooltip').textContent = '√áoklu Se√ßim';
        }
        deleteBtnSidebar.style.display = 'none';
        if (deleteBtnMobile) deleteBtnMobile.style.display = 'none';

        renderTree();
        saveToLocalStorage(); // Kaydetmeyi unutma!
        showToast(count + ' ki≈üi silindi!');
    } else {
        // "Emin misiniz?" onay mekanizmasƒ± (Senin kodunla aynƒ±)
        const msg = 'Emin misiniz? (' + selectedPeople.size + ' ki≈üi)';
        deleteBtnSidebar.title = msg;
        if (deleteBtnMobile) deleteBtnMobile.title = msg;
        deleteBtnSidebar.style.background = '#c82333';
        
        setTimeout(() => {
            deleteBtnSidebar.title = 'Se√ßilenleri Sil';
            deleteBtnSidebar.style.background = '#dc3545';
        }, 3000);
    }
}

    function clearSelection() {
      selectedPerson = null;
      connectingPerson = null;
      selectedPeople.clear();
      multiSelectMode = false;
      const tooltip = document.getElementById('multiSelectTooltip');
      if (tooltip) tooltip.textContent = '√áoklu Se√ßim';
      
      document.getElementById('deleteMultipleBtnSidebar').style.display = 'none';
      document.getElementById('editPersonBtnSidebar').style.display = 'none';
      
      const deleteBtnMobile = document.getElementById('deleteMultipleBtnMobile');
      const editBtnMobile = document.getElementById('editPersonBtnMobile');
      if (deleteBtnMobile) deleteBtnMobile.style.display = 'none';
      if (editBtnMobile) editBtnMobile.style.display = 'none';
      
      // Buton renklerini sƒ±fƒ±rla
      const multiSelectBtnSidebar = document.getElementById('multiSelectBtnSidebar');
      const multiSelectBtnMobile = document.getElementById('multiSelectBtnMobile');
      multiSelectBtnSidebar.style.borderColor = '#dee2e6';
      multiSelectBtnSidebar.style.background = 'white';
      multiSelectBtnMobile.style.borderColor = '#dee2e6';
      multiSelectBtnMobile.style.background = 'white';
      
      renderTree();
      showToast('Se√ßim temizlendi');
    }

    async function downloadImage() {
      const btnSidebar = document.getElementById('downloadImageBtnSidebar');
      const btnMobile = document.getElementById('downloadImageBtnMobile');
      
      btnSidebar.disabled = true;
      btnSidebar.title = '‚è≥ Hazƒ±rlanƒ±yor...';
      if (btnMobile) {
        btnMobile.disabled = true;
        btnMobile.title = '‚è≥ Hazƒ±rlanƒ±yor...';
      }
      
      try {
        // Kartlarƒ±n ve √ßizgilerin sƒ±nƒ±rlarƒ±nƒ± hesapla
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        // Kartlarƒ±n sƒ±nƒ±rlarƒ±
        people.forEach(person => {
          const cardLeft = person.x - CARD_WIDTH / 2;
          const cardRight = person.x + CARD_WIDTH / 2;
          const cardTop = person.y - CARD_HEIGHT / 2;
          const cardBottom = person.y + CARD_HEIGHT / 2;
          
          minX = Math.min(minX, cardLeft);
          maxX = Math.max(maxX, cardRight);
          minY = Math.min(minY, cardTop);
          maxY = Math.max(maxY, cardBottom);
        });
        
        // √áizgilerin sƒ±nƒ±rlarƒ±nƒ± hesapla
        const horizontalOffset = 40;
        const verticalOffset = CARD_HEIGHT / 2 + 110;
        const verticalStartOffset = CARD_HEIGHT / 2 + 60;
        
// E≈ü baƒülantƒ±larƒ± i√ßin sƒ±nƒ±rlar (Mevcut ve Eski E≈üler Dahil)
const drawnSpouseBounds = new Set();
people.forEach(person => {
  // Mevcut e≈ü + Eski e≈üler listesini birle≈ütiriyoruz
  const allSpouseIds = [];
  if (person.spouse) allSpouseIds.push(person.spouse);
  
  // BURAYI G√úNCELLEDƒ∞M: formerSpouses yerine spouses (veya her ikisi)
  if (person.spouses) allSpouseIds.push(...person.spouses);
  else if (person.formerSpouses) allSpouseIds.push(...person.formerSpouses);

  allSpouseIds.forEach(spouseId => {
    const key = [person.id, spouseId].sort().join('-');
    if (!drawnSpouseBounds.has(key)) {
      const spouse = people.find(p => p.id === spouseId);
      if (spouse) {
        // verticalOffset ve horizontalOffset'in tanƒ±mlƒ± olduƒüundan emin ol
        const connectionY = Math.max(person.y, spouse.y) + verticalOffset;
        minY = Math.min(minY, connectionY);
        maxY = Math.max(maxY, connectionY);
        
        const x1 = person.x + horizontalOffset;
        const x2 = spouse.x + horizontalOffset;
        minX = Math.min(minX, x1, x2);
        maxX = Math.max(maxX, x1, x2);
        
        drawnSpouseBounds.add(key);
      }
    }
  });
});
        
        // Ebeveyn-√ßocuk baƒülantƒ±larƒ± i√ßin sƒ±nƒ±rlar
        const processedParentGroups = new Set();
        people.forEach(child => {
          if (child.parents && child.parents.length > 0) {
            const parentKey = [...child.parents].sort().join('-');
            
            if (!processedParentGroups.has(parentKey)) {
              const children = people.filter(p => {
                if (!p.parents || p.parents.length === 0) return false;
                const pKey = [...p.parents].sort().join('-');
                return pKey === parentKey;
              });
              
              const parents = child.parents.map(id => people.find(p => p.id === id)).filter(Boolean);
              if (parents.length > 0) {
                const maxParentY = Math.max(...parents.map(p => p.y));
                const parentConnectionY = maxParentY + CARD_HEIGHT / 2 + 110;
                const bendPointY = parentConnectionY + 30;
                
                const parent1 = parents[0];
                const parent2 = parents.length > 1 ? parents[1] : parent1;
                const spouseConnectionMidX = ((parent1.x + parent2.x) / 2) + horizontalOffset;
                
                const childrenAvgX = children.reduce((sum, c) => sum + c.x, 0) / children.length;
                const childrenAvgY = children.reduce((sum, c) => sum + c.y, 0) / children.length;
                const greenLineX = childrenAvgX + horizontalOffset;
                const childConnectionY = childrenAvgY - CARD_HEIGHT / 2 - 30;
                
                minX = Math.min(minX, spouseConnectionMidX, greenLineX);
                maxX = Math.max(maxX, spouseConnectionMidX, greenLineX);
                minY = Math.min(minY, childConnectionY);
                maxY = Math.max(maxY, parentConnectionY, bendPointY);
                
                children.forEach(c => {
                  const x = c.x + horizontalOffset;
                  minX = Math.min(minX, x);
                  maxX = Math.max(maxX, x);
                });
              }
              
              processedParentGroups.add(parentKey);
            }
          }
        });
        
        // Karde≈ü baƒülantƒ±larƒ± i√ßin sƒ±nƒ±rlar
        const processedSiblingGroups = new Set();
        people.forEach(person => {
          if (person.siblings && person.siblings.length > 0) {
            const siblingGroupIds = new Set([person.id, ...person.siblings]);
            const groupKey = [...siblingGroupIds].sort().join('-');
            
            if (!processedSiblingGroups.has(groupKey)) {
              const siblingGroup = people.filter(p => siblingGroupIds.has(p.id));
              
              const minSibY = Math.min(...siblingGroup.map(s => s.y));
              const maxSibY = Math.max(...siblingGroup.map(s => s.y));
              const minSibX = Math.min(...siblingGroup.map(s => s.x));
              const maxSibX = Math.max(...siblingGroup.map(s => s.x));
              
              const verticalSpread = maxSibY - minSibY;
              const horizontalSpread = maxSibX - minSibX;
              
              if (verticalSpread <= horizontalSpread) {
                const connectionY = minSibY - CARD_HEIGHT / 2 - 10;
                minY = Math.min(minY, connectionY);
                
                siblingGroup.forEach(s => {
                  const x = s.x + horizontalOffset;
                  minX = Math.min(minX, x);
                  maxX = Math.max(maxX, x);
                });
              } else {
                siblingGroup.forEach(s => {
                  const x = s.x + 40;
                  minX = Math.min(minX, x);
                  maxX = Math.max(maxX, x);
                });
              }
              
              processedSiblingGroups.add(groupKey);
            }
          }
        });
        
        // 40px boÔøΩÔøΩluk ekle
        const padding = 40;
        minX -= padding;
        minY -= padding;
        maxX += padding;
        maxY += padding;
        
        const width = maxX - minX;
        const height = maxY - minY;
        
        // Canvas olu≈ütur
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        // Beyaz arka plan
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
        
        // Baƒülantƒ± √ßizgilerini √ßiz
        await drawConnectionsToCanvas(ctx, minX, minY);
        
        // Kartlarƒ± √ßiz
        await drawCardsToCanvas(ctx, minX, minY);
        
        // PNG olarak indir
        canvas.toBlob(function(blob) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'soy-agaci-' + new Date().getTime() + '.png';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          btnSidebar.disabled = false;
          btnSidebar.title = 'G√∂rseli ƒ∞ndir';
          if (btnMobile) {
            btnMobile.disabled = false;
            btnMobile.title = 'ƒ∞ndir';
          }
          showToast('‚úÖ G√∂rsel indirildi!');
        });
      } catch (error) {
        console.error('ƒ∞ndirme hatasƒ±:', error);
        showToast('‚ùå ƒ∞ndirme hatasƒ±: ' + error.message, true);
        btnSidebar.disabled = false;
        btnSidebar.title = 'G√∂rseli ƒ∞ndir';
        if (btnMobile) {
          btnMobile.disabled = false;
          btnMobile.title = 'ƒ∞ndir';
        }
      }
    }
async function drawConnectionsToCanvas(ctx, offsetX, offsetY) {
  // Ebeveyn-√ßocuk baƒülantƒ±larƒ± (Burasƒ± aynƒ± kalabilir)
  const processedParentGroups = new Set();
  people.forEach(child => {
    if (child.parents && child.parents.length > 0) {
      const parentKey = [...child.parents].sort().join('-');
      if (!processedParentGroups.has(parentKey)) {
        const children = people.filter(p => {
          if (!p.parents || p.parents.length === 0) return false;
          const pKey = [...p.parents].sort().join('-');
          return pKey === parentKey;
        });
        drawParentToChildrenConnectionCanvas(ctx, child.parents, children, offsetX, offsetY);
        processedParentGroups.add(parentKey);
      }
    }
  });

const drawnSpouses = new Set();
people.forEach(person => {
    // A. MEVCUT E≈û (D√úZ √áƒ∞ZGƒ∞)
    if (person.spouse) {
        const spouse = people.find(p => p.id === person.spouse);
        const key = [person.id, person.spouse].sort().join('-');
        if (spouse && !drawnSpouses.has(key)) {
            drawSpouseConnectionCanvas(ctx, person, spouse, offsetX, offsetY, false);
            drawnSpouses.add(key);
        }
    }

    // B. ESKƒ∞ E≈ûLER (KESƒ∞K √áƒ∞ZGƒ∞)
    if (person.spouses && person.spouses.length > 0) {
        person.spouses.forEach(sId => {
            const oldSpouse = people.find(p => p.id === sId);
            const key = [person.id, sId].sort().join('-');
            if (oldSpouse && !drawnSpouses.has(key)) {
                drawSpouseConnectionCanvas(ctx, person, oldSpouse, offsetX, offsetY, true);
                drawnSpouses.add(key);
            }
        });
    }
});

      
      // Karde≈ü baÔøΩÔøΩÔøΩÔøΩlantÔøΩÔøΩlarƒ±
      const processedSiblingGroups = new Set();
      people.forEach(person => {
        if (person.siblings && person.siblings.length > 0) {
          const siblingGroupIds = new Set([person.id, ...person.siblings]);
          const groupKey = [...siblingGroupIds].sort().join('-');
          
          if (!processedSiblingGroups.has(groupKey)) {
            const siblingGroup = people.filter(p => siblingGroupIds.has(p.id));
            drawSiblingConnectionCanvas(ctx, siblingGroup, offsetX, offsetY);
            processedSiblingGroups.add(groupKey);
          }
        }
      });
    }

// 2. √áizgiyi Ekrana Basan Temel Fonksiyon
function drawLineCanvas(ctx, x1, y1, x2, y2, color, width, dash = []) {
  ctx.beginPath();
// dash deƒüi≈ükeninin dizi olduƒüundan emin oluyoruz
if (Array.isArray(dash)) {
    ctx.setLineDash(dash);
} else if (dash === true) {
    ctx.setLineDash([5, 5]); // Kesik √ßizgi istenmi≈üse 5px √ßizgi, 5px bo≈üluk
} else {
    ctx.setLineDash([]); // D√ºz √ßizgi (bo≈ü dizi)
}  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.stroke(); // √áizgiyi √ßiz
  ctx.setLineDash([]); // AYARLARI SIFIRLA (√áok √ñnemli!)
}

// 1. Koordinatlarƒ± Hesaplayan Fonksiyon
function drawSpouseConnectionCanvas(ctx, person1, person2, offsetX, offsetY, isFormer = false) {
  const centerX1 = person1.x - offsetX;
  const centerY1 = person1.y - offsetY;
  const centerX2 = person2.x - offsetX;
  const centerY2 = person2.y - offsetY;
  
  const verticalOffset = CARD_HEIGHT / 2 + 70;
  const verticalStartOffset = CARD_HEIGHT / 2; // Ba≈ülangƒ±√ß noktasƒ±
  const connectionY = Math.max(centerY1, centerY2) + verticalOffset;
  
  // Kesik √ßizgi deseni: [10px dolu, 5px bo≈ü]
  const dashPattern = isFormer ? [10, 5] : []; 
  const color = '#f97316'; // Turuncu

  // drawLineCanvas'a dashPattern'i g√∂nderiyoruz
  drawLineCanvas(ctx, centerX1, centerY1 + verticalStartOffset, centerX1, connectionY, color, 3, dashPattern);
  drawLineCanvas(ctx, centerX2, centerY2 + verticalStartOffset, centerX2, connectionY, color, 3, dashPattern);
  drawLineCanvas(ctx, centerX1, connectionY, centerX2, connectionY, color, 3, dashPattern);
}

    function drawSiblingConnectionCanvas(ctx, siblingGroup, offsetX, offsetY) {
      if (!siblingGroup || siblingGroup.length < 2) return;
      
      const firstSibling = siblingGroup[0];
      const hasParents = firstSibling.parents && firstSibling.parents.length > 0;
      
      const minY = Math.min(...siblingGroup.map(s => s.y));
      const maxY = Math.max(...siblingGroup.map(s => s.y));
      const minX = Math.min(...siblingGroup.map(s => s.x));
      const maxX = Math.max(...siblingGroup.map(s => s.x));
      
      const verticalSpread = maxY - minY;
      const horizontalSpread = maxX - minX;
      
      if (verticalSpread <= horizontalSpread) {
        const horizontalOffset = 0;
        let connectionY;
        
        if (hasParents) {
          const childrenAvgY = siblingGroup.reduce((sum, s) => sum + s.y, 0) / siblingGroup.length;
          connectionY = childrenAvgY - CARD_HEIGHT / 2 - 20;
        } else {
          connectionY = minY - CARD_HEIGHT / 2 - 50;
        }
        
        siblingGroup.forEach(sibling => {
          const cardTop = sibling.y - CARD_HEIGHT / 2;
          drawLineCanvas(ctx, sibling.x + horizontalOffset - offsetX, cardTop - offsetY, sibling.x + horizontalOffset - offsetX, connectionY - offsetY, '#3b82f6', 3);
        });
        
        drawLineCanvas(ctx, minX + horizontalOffset - offsetX, connectionY - offsetY, maxX + horizontalOffset - offsetX, connectionY - offsetY, '#3b82f6', 3);
      } else {
        siblingGroup.sort((a, b) => a.y - b.y);
        
        for (let i = 0; i < siblingGroup.length - 1; i++) {
          const sibling1 = siblingGroup[i];
          const sibling2 = siblingGroup[i + 1];
          
          if (Math.abs(sibling1.x - sibling2.x) === 0) {
            const lineX = sibling1.x - offsetX;
            const y1 = sibling1.y - offsetY;
            const y2 = sibling2.y - offsetY;
            
            drawLineCanvas(ctx, lineX, y1, lineX, y2, '#3b82f6', 3);
          }
        }
      }
    }

    function drawParentToChildrenConnectionCanvas(ctx, parentIds, children, offsetX, offsetY) {
  if (!parentIds || parentIds.length === 0 || !children || children.length === 0) return;
  
  // Veri kaynaƒüƒ±nƒ± garantiye al
  const currentPeople = window.people || people;
  const parents = parentIds.map(id => currentPeople.find(p => p.id === id)).filter(Boolean);
  if (parents.length === 0) return;
  
  // --- √áizgi Tipi (D√ºz/Kesik) ---
  let isDashed = false;
  if (parents.length === 1) {
    const singleParent = parents[0];
    if (singleParent.spouse) {
      const spouse = currentPeople.find(p => p.id === singleParent.spouse);
      if (spouse) {
        const spouseIsParent = children.some(child => 
          child.parents && child.parents.includes(spouse.id)
        );
        isDashed = !spouseIsParent;
      }
    }
  }
  const dashArray = isDashed ? [5, 5] : null;

  // --- Koordinat Hesaplamalarƒ± ---
  const cH = (typeof CARD_HEIGHT !== 'undefined') ? CARD_HEIGHT : 90;
  
  // 1. TURUNCU √áƒ∞ZGƒ∞ ORTA NOKTASI (Ye≈üil hat buradan ba≈ülamalƒ±)
  // Ebeveynlerin X ortalamasƒ±
  const parent1 = parents[0];
  const parent2 = parents.length > 1 ? parents[1] : parent1;
  const spouseConnectionMidX = ((parent1.x + parent2.x) / 2) - offsetX;
  
  // Turuncu √ßizginin Y seviyesi (U-tipi baƒülantƒ±nƒ±n en altƒ±)
  const maxParentY = Math.max(...parents.map(p => p.y));
  const parentConnectionY = maxParentY + cH / 2 + 70 - offsetY;

  // 2. √áOCUK BAƒûLANTI SEVƒ∞YESƒ∞
  // √áocuklarƒ±n en √ºst noktasƒ±ndan biraz yukarƒ±da bir "daƒüƒ±tƒ±m hattƒ±" kuruyoruz
  const minChildY = Math.min(...children.map(c => c.y));
  const childConnectionY = minChildY - cH / 2 - 40 - offsetY;

  // 3. √áƒ∞Zƒ∞M
  // A. Ebeveynlerin ortasƒ±ndan (turuncudan) √ßocuklarƒ±n hizasƒ±na inen ana dikey hat
  drawLineCanvas(ctx, spouseConnectionMidX, parentConnectionY, spouseConnectionMidX, childConnectionY, '#10b981', 3, dashArray);
  
  // B. √áocuklara daƒüƒ±lan yatay hat ve a≈üaƒüƒ± inen kollar
  children.forEach(child => {
    const childX = child.x - offsetX;
    const childTop = child.y - cH / 2 - offsetY;

    // Yatay kol (Ana dikey hattan √ßocuƒüun hizasƒ±na)
    drawLineCanvas(ctx, spouseConnectionMidX, childConnectionY, childX, childConnectionY, '#10b981', 3, dashArray);
    
    // √áocuƒüun kafasƒ±na inen dikey kol
    drawLineCanvas(ctx, childX, childConnectionY, childX, childTop, '#10b981', 3, dashArray);
  });
}

    async function drawCardsToCanvas(ctx, offsetX, offsetY) {
      ctx.font = 'bold 16px "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      for (const person of people) {
        const x = person.x - CARD_WIDTH / 2 - offsetX;
        const y = person.y - CARD_HEIGHT / 2 - offsetY;
        
        // Gradient arka plan
        const gradient = ctx.createLinearGradient(x, y, x + CARD_WIDTH, y + CARD_HEIGHT);
        if (person.gender === 'erkek') {
          gradient.addColorStop(0, '#60a5fa');
          gradient.addColorStop(1, '#3b82f6');
        } else {
          gradient.addColorStop(0, '#f9a8d4');
          gradient.addColorStop(1, '#ec4899');
        }
        
        // Kart arka planƒ±
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.roundRect(x, y, CARD_WIDTH, CARD_HEIGHT, 8);
        ctx.fill();
        
        // Beyaz kenarlƒ±k
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // ƒ∞sim
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px "Segoe UI", sans-serif';
        ctx.shadowColor = 'rgba(0,0,0,0.2)';
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 1;
        
        // ƒ∞sim uzunsa alt satƒ±ra kay
        const maxWidth = CARD_WIDTH - 20;
        const words = person.name.split(' ');
        let line = '';
        let textY = y + CARD_HEIGHT / 2;
        
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + ' ';
          const metrics = ctx.measureText(testLine);
          
          if (metrics.width > maxWidth && i > 0) {
            ctx.fillText(line, x + CARD_WIDTH / 2, textY - 5);
            line = words[i] + ' ';
            textY += 18;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x + CARD_WIDTH / 2, textY - 5);
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      }
    }

    document.getElementById('closeModalBtn').addEventListener('click', function() {
      document.getElementById('addPersonModal').classList.remove('active');
      document.getElementById('addPersonForm').reset();
      editingPersonId = null;
    });

document.getElementById('addPersonForm').addEventListener('submit', function(e) {
  e.preventDefault();

  const name = document.getElementById('personName').value;
  const gender = document.getElementById('personGender').value;
  const birthYear = document.getElementById('personBirthYear').value ? parseInt(document.getElementById('personBirthYear').value) : null;
  const notes = document.getElementById('personNotes').value || '';
  const newSpouseId = document.getElementById('personSpouse')?.value ? parseInt(document.getElementById('personSpouse').value) : null;

  if (editingPersonId) {
    // editingPersonId'nin number olduƒüundan emin olalƒ±m
    const person = people.find(p => p.id == editingPersonId);
    
    if (person) {
      const oldSpouseId = person.spouse;

      // EƒûER E≈û DEƒûƒ∞≈ûTƒ∞YSE (Mehmet'in e≈üi Ay≈üe'den ba≈ükasƒ± yapƒ±ldƒ±ysa)
      if (oldSpouseId && oldSpouseId !== newSpouseId) {
        console.log("Sistem: E≈ü deƒüi≈üikliƒüi algƒ±landƒ±. Eski e≈ü ID:", oldSpouseId);

        // 1. Mehmet'in eski e≈üler listesini g√ºncelle
        if (!person.spouses) person.spouses = [];
        if (!person.spouses.includes(oldSpouseId)) {
          person.spouses.push(oldSpouseId);
          console.log("Sistem: Eski e≈ü Mehmet'in listesine eklendi.");
        }

        // 2. Ay≈üe'nin (Eski e≈ü) verisini g√ºncelle
        const oldSpouse = people.find(p => p.id == oldSpouseId);
        if (oldSpouse) {
          oldSpouse.spouse = null; // Aktif baƒüƒ± kopar
          if (!oldSpouse.spouses) oldSpouse.spouses = [];
          if (!oldSpouse.spouses.includes(person.id)) {
            oldSpouse.spouses.push(person.id); 
          }
        }
      }

      // 3. Yeni e≈üi baƒüla
      person.spouse = newSpouseId;
      if (newSpouseId) {
        const target = people.find(p => p.id == newSpouseId);
        if (target) target.spouse = person.id;
      }

      // Bilgileri g√ºncelle
      person.name = name;
      person.gender = gender;
      person.birthYear = birthYear;
      person.notes = notes;
    }
  } else {
    // Yeni ki≈üi ekleme (Burada spouses: [] bo≈ü ba≈ülar)
    const newPerson = {
      id: Date.now(),
      name, gender, birthYear, notes,
      x: (150 / currentScale) - currentTranslateX,
      y: (150 / currentScale) - currentTranslateY,
      spouse: newSpouseId,
      spouses: [], // Her zaman diziyle ba≈üla
      parents: [],
      children: [], // Buraya ekledik! Artƒ±k her yeni kartƒ±n i√ßinde hazƒ±r bekliyor.
      siblings: []
    };
    if (newSpouseId) {
      const target = people.find(p => p.id == newSpouseId);
      if (target) target.spouse = newPerson.id;
    }
    people.push(newPerson);
  }

  renderTree();
  saveToLocalStorage();
  document.getElementById('addPersonModal').classList.remove('active');
  editingPersonId = null;
});


    document.getElementById('closeRelModalBtn').addEventListener('click', closeRelationshipModal);
    document.getElementById('cancelRelBtn').addEventListener('click', closeRelationshipModal);
    
    document.getElementById('spouseBtn').addEventListener('click', function() { 
      createRelationship('spouse'); 
    });
    
    document.getElementById('parentChildBtn').addEventListener('click', function() { 
      createRelationship('parent-child'); 
    });
    
    document.getElementById('childParentBtn').addEventListener('click', function() { 
      createRelationship('child-parent'); 
    });
    
    document.getElementById('siblingBtn').addEventListener('click', function() { 
      createRelationship('sibling'); 
    });
    
    document.getElementById('deleteRelationshipBtn').addEventListener('click', deleteExistingRelationship);

    // Initialize - Auto-load from localStorage if available
    function initializeApp() {
      const savedData = localStorage.getItem(STORAGE_KEY);
      
      if (savedData) {
        try {
          const data = JSON.parse(savedData);
          people = data.people;
          renderTree();
          
          // Kartlarƒ± ekranƒ±n ortasƒ±na getir
          setTimeout(() => {
            centerViewOnCards();
          }, 100);
          
          showToast('üéâ Kaydedilmi≈ü soy aƒüacƒ± y√ºklendi!');
        } catch (error) {
          console.error('Y√ºkleme hatasƒ±:', error);
          renderTree();
          setTimeout(() => {
            centerViewOnCards();
          }, 100);
          showToast('Yeni soy aƒüacƒ± ba≈ülatƒ±ldƒ±!');
        }
      } else {
        renderTree();
        setTimeout(() => {
          centerViewOnCards();
        }, 100);
        showToast('üéØ Tut-s√ºr√ºkle ile hareket ettirin!');
      }
    }

    function centerViewOnCards() {
      if (people.length === 0) return;
      
      const container = document.getElementById('treeContainer');
      
      // T√ºm kartlarƒ±n sƒ±nƒ±rlarƒ±nƒ± bul
      let minX = Infinity, minY = Infinity;
      people.forEach(p => {
        minX = Math.min(minX, p.x - CARD_WIDTH / 2);
        minY = Math.min(minY, p.y - CARD_HEIGHT / 2);
      });
      
      // Sol √ºst k√∂≈üeden 50px bo≈üluk bƒ±rak
      const targetX = 30;
      const targetY = 30;
      
      // En soldaki ve en √ºstteki kartƒ± hedef pozisyona ta≈üƒ±
      currentTranslateX = targetX / currentScale - minX;
      currentTranslateY = targetY / currentScale - minY;
      
      applyZoomTransform();
    }

    initializeApp();
  </script>
 </body>
</html>

